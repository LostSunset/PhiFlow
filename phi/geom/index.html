<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>phi.geom API documentation</title>
<meta name="description" content="Differentiable geometry package …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.geom</code></h1>
</header>
<section id="section-intro">
<p>Differentiable geometry package.</p>
<p>Classes:</p>
<ul>
<li><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> (base type)</li>
<li><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></li>
<li><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></li>
</ul>
<p>See the <code><a title="phi.geom" href="#phi.geom">phi.geom</a></code> module documentation at <a href="https://tum-pbs.github.io/PhiFlow/Geometry.html">https://tum-pbs.github.io/PhiFlow/Geometry.html</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Differentiable geometry package.

Classes:

* `Geometry` (base type)
* `Box`
* `Sphere`

See the `phi.geom` module documentation at https://tum-pbs.github.io/PhiFlow/Geometry.html
&#34;&#34;&#34;
from ..math import stack, concat, pack_dims  # for compatibility
from ._geom import Geometry, Point, assert_same_rank, invert
from ._union import union
from ._box import Box, GridCell, BaseBox, Cuboid
from ._sphere import Sphere
from ._transform import embed, infinite_cylinder

__all__ = [key for key in globals().keys() if not key.startswith(&#39;_&#39;)]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.geom.assert_same_rank"><code class="name flex">
<span>def <span class="ident">assert_same_rank</span></span>(<span>rank1, rank2, error_message)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests that two objects have the same spatial rank. Objects can be of types: <code>int</code>, <code>None</code> (no check), <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>, <code>Shape</code>, <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_same_rank(rank1, rank2, error_message):
    &#34;&#34;&#34; Tests that two objects have the same spatial rank. Objects can be of types: `int`, `None` (no check), `Geometry`, `Shape`, `Tensor` &#34;&#34;&#34;
    rank1_, rank2_ = _rank(rank1), _rank(rank2)
    if rank1_ is not None and rank2_ is not None:
        assert rank1_ == rank2_, &#39;Ranks do not match: %s and %s. %s&#39; % (rank1_, rank2_, error_message)</code></pre>
</details>
</dd>
<dt id="phi.geom.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>values: tuple, dim: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates a sequence of <code><a title="phi.math.magic.Shapable" href="../math/magic.html#phi.math.magic.Shapable">Shapable</a></code> objects, e.g. <code>Tensor</code>, along one dimension.
All values must have the same spatial, instance and channel dimensions and their sizes must be equal, except for <code>dim</code>.
Batch dimensions will be added as needed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Tuple or list of <code><a title="phi.math.magic.Shapable" href="../math/magic.html#phi.math.magic.Shapable">Shapable</a></code>, such as <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code></dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Concatenation dimension, must be present in all <code>values</code>.
The size along <code>dim</code> is determined from <code>values</code> and can be set to undefined (<code>None</code>).</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated <code>Tensor</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; concat([math.zeros(batch(b=10)), math.ones(batch(b=10))], 'b')
(bᵇ=20) 0.500 ± 0.500 (0e+00...1e+00)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; concat([vec(x=1, y=0), vec(z=2.)], 'vector')
(x=1.000, y=0.000, z=2.000) float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(values: tuple or list, dim: str or Shape, **kwargs):
    &#34;&#34;&#34;
    Concatenates a sequence of `phi.math.magic.Shapable` objects, e.g. `Tensor`, along one dimension.
    All values must have the same spatial, instance and channel dimensions and their sizes must be equal, except for `dim`.
    Batch dimensions will be added as needed.

    Args:
        values: Tuple or list of `phi.math.magic.Shapable`, such as `phi.math.Tensor`
        dim: Concatenation dimension, must be present in all `values`.
            The size along `dim` is determined from `values` and can be set to undefined (`None`).
        **kwargs: Additional keyword arguments required by specific implementations.
            Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
            Adding batch dimensions must always work without keyword arguments.

    Returns:
        Concatenated `Tensor`

    Examples:
        &gt;&gt;&gt; concat([math.zeros(batch(b=10)), math.ones(batch(b=10))], &#39;b&#39;)
        (bᵇ=20) 0.500 ± 0.500 (0e+00...1e+00)

        &gt;&gt;&gt; concat([vec(x=1, y=0), vec(z=2.)], &#39;vector&#39;)
        (x=1.000, y=0.000, z=2.000) float64
    &#34;&#34;&#34;
    assert len(values) &gt; 0, f&#34;concat() got empty sequence {values}&#34;
    if isinstance(dim, Shape):
        dim = dim.name
    assert isinstance(dim, str), f&#34;dim must be a str or Shape but got &#39;{dim}&#39; of type {type(dim)}&#34;
    for v in values:
        assert dim in shape(v), f&#34;dim must be present in the shapes of all values bot got value {type(v).__name__} with shape {shape(v)}&#34;
    for v in values[1:]:
        assert set(non_batch(v).names) == set(non_batch(values[0]).names), f&#34;Concatenated values must have the same non-batch dimensions but got {non_batch(values[0])} and {non_batch(v)}&#34;
    # Add missing batch dimensions
    all_batch_dims = merge_shapes(*[batch(v) for v in values])
    values = [expand(v, all_batch_dims) for v in values]
    # --- First try __concat__ ---
    for v in values:
        if isinstance(v, Shapable):
            if hasattr(v, &#39;__concat__&#39;):
                result = v.__concat__(values, dim, **kwargs)
                if result is not NotImplemented:
                    assert isinstance(result, Shapable), f&#34;__concat__ must return a Shapable object but got {type(result).__name__} from {type(v).__name__} {v}&#34;
                    return result
    # --- Next: try concat attributes for tree nodes ---
    if all(isinstance(v, PhiTreeNode) for v in values):
        attributes = all_attributes(values[0])
        if attributes and all(all_attributes(v) == attributes for v in values):
            new_attrs = {}
            for a in attributes:
                common_shape = merge_shapes(*[shape(getattr(v, a)).without(dim) for v in values])
                a_values = [expand(getattr(v, a), common_shape &amp; shape(v).only(dim)) for v in values]  # expand by dim if missing, and dims of others
                new_attrs[a] = concat(a_values, dim, **kwargs)
            return copy_with(values[0], **new_attrs)
        else:
            warnings.warn(f&#34;Failed to concat values using value attributes because attributes differ among values {values}&#34;)
    # --- Fallback: slice and stack ---
    try:
        unstacked = sum([unstack(v, dim) for v in values], ())
    except MagicNotImplemented:
        raise MagicNotImplemented(f&#34;concat: No value implemented __concat__ and not all values were Sliceable along {dim}. values = {[type(v) for v in values]}&#34;)
    if len(unstacked) &gt; 8:
        warnings.warn(f&#34;concat() default implementation is slow on large dimensions ({dim}={len(unstacked)}). Please implement __concat__()&#34;, RuntimeWarning, stacklevel=2)
    dim = shape(values[0])[dim].with_size(None)
    try:
        return stack(unstacked, dim, **kwargs)
    except MagicNotImplemented:
        raise MagicNotImplemented(f&#34;concat: No value implemented __concat__ and slices could not be stacked. values = {[type(v) for v in values]}&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.embed"><code class="name flex">
<span>def <span class="ident">embed</span></span>(<span>geometry: phi.geom._geom.Geometry, projected_dims: phi.math._shape.Shape) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Adds fake spatial dimensions to a geometry.
The geometry value will be constant along the added dimensions, as if it had infinite length in these directions.</p>
<p>Dimensions that are already present with <code>geometry</code> are ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dd>
<dt><strong><code>projected_dims</code></strong></dt>
<dd>Additional dimensions</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with spatial rank <code>geometry.spatial_rank + projected_dims.rank</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed(geometry: Geometry, projected_dims: math.Shape or str or tuple or list or None) -&gt; Geometry:
    &#34;&#34;&#34;
    Adds fake spatial dimensions to a geometry.
    The geometry value will be constant along the added dimensions, as if it had infinite length in these directions.

    Dimensions that are already present with `geometry` are ignored.

    Args:
        geometry: `Geometry`
        projected_dims: Additional dimensions

    Returns:
        `Geometry` with spatial rank `geometry.spatial_rank + projected_dims.rank`.
    &#34;&#34;&#34;
    if projected_dims is None:
        return geometry
    axes = parse_dim_order(projected_dims)
    embedded_axes = [a for a in axes if a not in geometry.shape.get_item_names(&#39;vector&#39;)]
    if not embedded_axes:
        return geometry
    for name in reversed(geometry.shape.get_item_names(&#39;vector&#39;)):
        if name not in projected_dims:
            axes = (name,) + axes
    if isinstance(geometry, BaseBox):
        box = geometry.corner_representation()
        return box * Box(**{dim: None for dim in embedded_axes})
    return _EmbeddedGeometry(geometry, axes)</code></pre>
</details>
</dd>
<dt id="phi.geom.infinite_cylinder"><code class="name flex">
<span>def <span class="ident">infinite_cylinder</span></span>(<span>center=None, radius=None, inf_dim: str = None, **center_) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an infinite cylinder.
This is equal to embedding an <code>n</code>-dimensional <code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code> in <code>n+1</code> dimensions.</p>
<p>See Also:
<code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code>, <code><a title="phi.geom.embed" href="#phi.geom.embed">embed()</a></code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Center coordinates without <code>inf_dim</code>. Alternatively use keyword arguments.</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Cylinder radius.</dd>
<dt><strong><code>inf_dim</code></strong></dt>
<dd>Dimension along which the cylinder is infinite.
Use <code><a title="phi.geom.Geometry.rotated" href="#phi.geom.Geometry.rotated">Geometry.rotated()</a></code> if the direction does not align with an axis.</dd>
<dt><strong><code>**center_</code></strong></dt>
<dd>Alternatively specify center coordinates without <code>inf_dim</code> as keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infinite_cylinder(center=None, radius=None, inf_dim: str or Shape or tuple or list = None, **center_) -&gt; Geometry:
    &#34;&#34;&#34;
    Creates an infinite cylinder.
    This is equal to embedding an `n`-dimensional `Sphere` in `n+1` dimensions.

    See Also:
        `Sphere`, `embed`

    Args:
        center: Center coordinates without `inf_dim`. Alternatively use keyword arguments.
        radius: Cylinder radius.
        inf_dim: Dimension along which the cylinder is infinite.
            Use `Geometry.rotated()` if the direction does not align with an axis.
        **center_: Alternatively specify center coordinates without `inf_dim` as keyword arguments.

    Returns:
        `Geometry`
    &#34;&#34;&#34;
    sphere = Sphere(center, radius, **center_)
    return embed(sphere, inf_dim)</code></pre>
</details>
</dd>
<dt id="phi.geom.invert"><code class="name flex">
<span>def <span class="ident">invert</span></span>(<span>geometry: phi.geom._geom.Geometry)</span>
</code></dt>
<dd>
<div class="desc"><p>Swaps inside and outside.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> to swap</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> object with same surface but swapped normals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert(geometry: Geometry):
    &#34;&#34;&#34;
    Swaps inside and outside.

    Args:
        geometry: `phi.geom.Geometry` to swap

    Returns:
        New `phi.geom.Geometry` object with same surface but swapped normals
    &#34;&#34;&#34;
    return ~geometry</code></pre>
</details>
</dd>
<dt id="phi.geom.pack_dims"><code class="name flex">
<span>def <span class="ident">pack_dims</span></span>(<span>value, dims: Union[str, tuple, list, set, phi.math._shape.Shape, Callable], packed_dim: phi.math._shape.Shape, pos: int = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Compresses multiple dimensions into a single dimension by concatenating the elements.
Elements along the new dimensions are laid out according to the order of <code>dims</code>.
If the order of <code>dims</code> differs from the current dimension order, the tensor is transposed accordingly.
This function replaces the traditional <code>reshape</code> for these cases.</p>
<p>The type of the new dimension will be equal to the types of <code>dims</code>.
If <code>dims</code> have varying types, the new dimension will be a batch dimension.</p>
<p>If none of <code>dims</code> exist on <code>value</code>, <code>packed_dim</code> will be added only if it is given with a definite size and <code>value</code> is not a primitive type.</p>
<p>See Also:
<code>unpack_dim()</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd><code><a title="phi.math.magic.Shapable" href="../math/magic.html#phi.math.magic.Shapable">Shapable</a></code>, such as <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code>.</dd>
<dt><strong><code>dims</code></strong></dt>
<dd>Dimensions to be compressed in the specified order.</dd>
<dt><strong><code>packed_dim</code></strong></dt>
<dd>Single-dimension <code>Shape</code>.</dd>
<dt><strong><code>pos</code></strong></dt>
<dd>Index of new dimension. <code>None</code> for automatic, <code>-1</code> for last, <code>0</code> for first.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Same type as <code>value</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; pack_dims(math.zeros(spatial(x=4, y=3)), spatial, instance('points'))
(pointsⁱ=12) const 0.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pack_dims(value, dims: DimFilter, packed_dim: Shape, pos: int or None = None, **kwargs):
    &#34;&#34;&#34;
    Compresses multiple dimensions into a single dimension by concatenating the elements.
    Elements along the new dimensions are laid out according to the order of `dims`.
    If the order of `dims` differs from the current dimension order, the tensor is transposed accordingly.
    This function replaces the traditional `reshape` for these cases.

    The type of the new dimension will be equal to the types of `dims`.
    If `dims` have varying types, the new dimension will be a batch dimension.

    If none of `dims` exist on `value`, `packed_dim` will be added only if it is given with a definite size and `value` is not a primitive type.

    See Also:
        `unpack_dim()`

    Args:
        value: `phi.math.magic.Shapable`, such as `phi.math.Tensor`.
        dims: Dimensions to be compressed in the specified order.
        packed_dim: Single-dimension `Shape`.
        pos: Index of new dimension. `None` for automatic, `-1` for last, `0` for first.
        **kwargs: Additional keyword arguments required by specific implementations.
            Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
            Adding batch dimensions must always work without keyword arguments.

    Returns:
        Same type as `value`.

    Examples:
        &gt;&gt;&gt; pack_dims(math.zeros(spatial(x=4, y=3)), spatial, instance(&#39;points&#39;))
        (pointsⁱ=12) const 0.0
    &#34;&#34;&#34;
    if isinstance(value, (Number, bool)):
        return value
    assert isinstance(value, Shapable) and isinstance(value, Sliceable) and isinstance(value, Shaped), f&#34;value must be Shapable but got {type(value)}&#34;
    dims = shape(value).only(dims, reorder=True)
    if packed_dim in shape(value):
        assert packed_dim in dims, f&#34;Cannot pack dims into new dimension {packed_dim} because it already exists on value {value} and is not packed.&#34;
    if len(dims) == 0 or all(dim not in shape(value) for dim in dims):
        return value if packed_dim.size is None else expand(value, packed_dim, **kwargs)  # Inserting size=1 can cause shape errors
    elif len(dims) == 1:
        return rename_dims(value, dims, packed_dim, **kwargs)
    # --- First try __pack_dims__ ---
    if hasattr(value, &#39;__pack_dims__&#39;):
        result = value.__pack_dims__(dims.names, packed_dim, pos, **kwargs)
        if result is not NotImplemented:
            return result
    # --- Next try Tree Node ---
    if isinstance(value, PhiTreeNode):
        new_attributes = {a: pack_dims(getattr(value, a), dims, packed_dim, pos=pos, **kwargs) for a in all_attributes(value)}
        return copy_with(value, **new_attributes)
    # --- Fallback: unstack and stack ---
    if shape(value).only(dims).volume &gt; 8:
        warnings.warn(f&#34;pack_dims() default implementation is slow on large dimensions ({shape(value).only(dims)}). Please implement __pack_dims__() for {type(value).__name__} as defined in phi.math.magic&#34;, RuntimeWarning, stacklevel=2)
    return stack(unstack(value, dims), packed_dim, **kwargs)</code></pre>
</details>
</dd>
<dt id="phi.geom.stack"><code class="name flex">
<span>def <span class="ident">stack</span></span>(<span>values: tuple, dim: phi.math._shape.Shape, expand_values=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Stacks <code>values</code> along the new dimension <code>dim</code>.
All values must have the same spatial, instance and channel dimensions. If the dimension sizes vary, the resulting tensor will be non-uniform.
Batch dimensions will be added as needed.</p>
<p>Stacking tensors is performed lazily, i.e. the memory is allocated only when needed.
This makes repeated stacking and slicing along the same dimension very efficient, i.e. jit-compiled functions will not perform these operations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Collection of <code><a title="phi.math.magic.Shapable" href="../math/magic.html#phi.math.magic.Shapable">Shapable</a></code>, such as <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code>
If a <code>dict</code>, keys must be of type <code>str</code> and are used as item names along <code>dim</code>.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd><code>Shape</code> with a least one dimension. None of these dimensions can be present with any of the <code>values</code>.
If <code>dim</code> is a single-dimension shape, its size is determined from <code>len(values)</code> and can be left undefined (<code>None</code>).
If <code>dim</code> is a multi-dimension shape, its volume must be equal to <code>len(values)</code>.</dd>
<dt><strong><code>expand_values</code></strong></dt>
<dd>If <code>True</code>, will first add missing dimensions to all values, not just batch dimensions.
This allows tensors with different dimensions to be stacked.
The resulting tensor will have all dimensions that are present in <code>values</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing <code>values</code> stacked along <code>dim</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack({'x': 0, 'y': 1}, channel('vector'))
(x=0, y=1)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack([math.zeros(batch(b=2)), math.ones(batch(b=2))], channel(c='x,y'))
(x=0.000, y=1.000); (x=0.000, y=1.000) (bᵇ=2, cᶜ=x,y)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; stack([vec(x=1, y=0), vec(x=2, y=3.)], batch('b'))
(x=1.000, y=0.000); (x=2.000, y=3.000) (bᵇ=2, vectorᶜ=x,y)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack(values: tuple or list or dict, dim: Shape, expand_values=False, **kwargs):
    &#34;&#34;&#34;
    Stacks `values` along the new dimension `dim`.
    All values must have the same spatial, instance and channel dimensions. If the dimension sizes vary, the resulting tensor will be non-uniform.
    Batch dimensions will be added as needed.

    Stacking tensors is performed lazily, i.e. the memory is allocated only when needed.
    This makes repeated stacking and slicing along the same dimension very efficient, i.e. jit-compiled functions will not perform these operations.

    Args:
        values: Collection of `phi.math.magic.Shapable`, such as `phi.math.Tensor`
            If a `dict`, keys must be of type `str` and are used as item names along `dim`.
        dim: `Shape` with a least one dimension. None of these dimensions can be present with any of the `values`.
            If `dim` is a single-dimension shape, its size is determined from `len(values)` and can be left undefined (`None`).
            If `dim` is a multi-dimension shape, its volume must be equal to `len(values)`.
        expand_values: If `True`, will first add missing dimensions to all values, not just batch dimensions.
            This allows tensors with different dimensions to be stacked.
            The resulting tensor will have all dimensions that are present in `values`.
        **kwargs: Additional keyword arguments required by specific implementations.
            Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
            Adding batch dimensions must always work without keyword arguments.

    Returns:
        `Tensor` containing `values` stacked along `dim`.

    Examples:
        &gt;&gt;&gt; stack({&#39;x&#39;: 0, &#39;y&#39;: 1}, channel(&#39;vector&#39;))
        (x=0, y=1)

        &gt;&gt;&gt; stack([math.zeros(batch(b=2)), math.ones(batch(b=2))], channel(c=&#39;x,y&#39;))
        (x=0.000, y=1.000); (x=0.000, y=1.000) (bᵇ=2, cᶜ=x,y)

        &gt;&gt;&gt; stack([vec(x=1, y=0), vec(x=2, y=3.)], batch(&#39;b&#39;))
        (x=1.000, y=0.000); (x=2.000, y=3.000) (bᵇ=2, vectorᶜ=x,y)
    &#34;&#34;&#34;
    assert len(values) &gt; 0, f&#34;stack() got empty sequence {values}&#34;
    assert isinstance(dim, Shape)
    values_ = tuple(values.values()) if isinstance(values, dict) else values
    if not expand_values:
        for v in values_[1:]:
            assert set(non_batch(v).names) == set(non_batch(values_[0]).names), f&#34;Stacked values must have the same non-batch dimensions but got {non_batch(values_[0])} and {non_batch(v)}&#34;
    # --- Add missing dimensions ---
    if expand_values:
        all_dims = merge_shapes(*values_, allow_varying_sizes=True)
        if isinstance(values, dict):
            values = {k: expand(v, all_dims.without(shape(v))) for k, v in values.items()}
        else:
            values = [expand(v, all_dims.without(shape(v))) for v in values]
    else:
        all_batch_dims = merge_shapes(*[batch(v) for v in values_], allow_varying_sizes=True)
        if isinstance(values, dict):
            values = {k: expand(v, all_batch_dims.without(shape(v))) for k, v in values.items()}
        else:
            values = [expand(v, all_batch_dims.without(shape(v))) for v in values]
    if dim.rank == 1:
        assert dim.size == len(values) or dim.size is None, f&#34;stack dim size must match len(values) or be undefined but got {dim} for {len(values)} values&#34;
        if dim.size is None:
            dim = dim.with_size(len(values))
        if isinstance(values, dict):
            dim_item_names = tuple(values.keys())
            values = tuple(values.values())
            dim = dim.with_size(dim_item_names)
        # --- First try __stack__ ---
        for v in values:
            if hasattr(v, &#39;__stack__&#39;):
                result = v.__stack__(values, dim, **kwargs)
                if result is not NotImplemented:
                    assert isinstance(result, Shapable), &#34;__stack__ must return a Shapable object&#34;
                    return result
        # --- Next: try stacking attributes for tree nodes ---
        if all(isinstance(v, PhiTreeNode) for v in values):
            attributes = all_attributes(values[0])
            if attributes and all(all_attributes(v) == attributes for v in values):
                new_attrs = {}
                for a in attributes:
                    assert all(dim not in shape(getattr(v, a)) for v in values), f&#34;Cannot stack attribute {a} because one values contains the stack dimension {dim}.&#34;
                    a_values = [getattr(v, a) for v in values]
                    if all(v is a_values[0] for v in a_values[1:]):
                        new_attrs[a] = expand(a_values[0], dim, **kwargs)
                    else:
                        new_attrs[a] = stack(a_values, dim, expand_values=expand_values, **kwargs)
                return copy_with(values[0], **new_attrs)
            else:
                warnings.warn(f&#34;Failed to concat values using value attributes because attributes differ among values {values}&#34;)
        # --- Fallback: use expand and concat ---
        for v in values:
            if not hasattr(v, &#39;__stack__&#39;) and hasattr(v, &#39;__concat__&#39;) and hasattr(v, &#39;__expand__&#39;):
                expanded_values = tuple([expand(v, dim.with_size(1 if dim.item_names[0] is None else dim.item_names[0][i]), **kwargs) for i, v in enumerate(values)])
                if len(expanded_values) &gt; 8:
                    warnings.warn(f&#34;stack() default implementation is slow on large dimensions ({dim.name}={len(expanded_values)}). Please implement __stack__()&#34;, RuntimeWarning, stacklevel=2)
                result = v.__concat__(expanded_values, dim.name, **kwargs)
                if result is not NotImplemented:
                    assert isinstance(result, Shapable), &#34;__concat__ must return a Shapable object&#34;
                    return result
        # --- else maybe all values are native scalars ---
        from ._tensors import wrap
        try:
            values = tuple([wrap(v) for v in values])
        except ValueError:
            raise MagicNotImplemented(f&#34;At least one item in values must be Shapable but got types {[type(v) for v in values]}&#34;)
        return values[0].__stack__(values, dim, **kwargs)
    else:  # multi-dim stack
        assert dim.volume == len(values), f&#34;When passing multiple stack dims, their volume must equal len(values) but got {dim} for {len(values)} values&#34;
        if isinstance(values, dict):
            warnings.warn(f&#34;When stacking a dict along multiple dimensions, the key names are discarded. Got keys {tuple(values.keys())}&#34;, RuntimeWarning, stacklevel=2)
            values = tuple(values.values())
        # --- if any value implements Shapable, use stack and unpack_dim ---
        for v in values:
            if hasattr(v, &#39;__stack__&#39;) and hasattr(v, &#39;__unpack_dim__&#39;):
                stack_dim = batch(&#39;_stack&#39;)
                stacked = v.__stack__(values, stack_dim, **kwargs)
                if stacked is not NotImplemented:
                    assert isinstance(stacked, Shapable), &#34;__stack__ must return a Shapable object&#34;
                    assert hasattr(stacked, &#39;__unpack_dim__&#39;), &#34;If a value supports __unpack_dim__, the result of __stack__ must also support it.&#34;
                    reshaped = stacked.__unpack_dim__(stack_dim.name, dim, **kwargs)
                    if kwargs is NotImplemented:
                        warnings.warn(&#34;__unpack_dim__ is overridden but returned NotImplemented during multi-dimensional stack. This results in unnecessary stack operations.&#34;, RuntimeWarning, stacklevel=2)
                    else:
                        return reshaped
        # --- Fallback: multi-level stack ---
        for dim_ in reversed(dim):
            values = [stack(values[i:i + dim_.size], dim_, **kwargs) for i in range(0, len(values), dim_.size)]
        return values[0]</code></pre>
</details>
</dd>
<dt id="phi.geom.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>*geometries) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Union of the given geometries.
A point lies inside the union if it lies within at least one of the geometries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometries</code></strong></dt>
<dd>arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.</dd>
<dt><strong><code>*geometries</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>union Geometry</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(*geometries) -&gt; Geometry:
    &#34;&#34;&#34;
    Union of the given geometries.
    A point lies inside the union if it lies within at least one of the geometries.

    Args:
      geometries: arbitrary geometries with same spatial dims. Arbitrary batch dims are allowed.
      *geometries: 

    Returns:
      union Geometry

    &#34;&#34;&#34;
    if len(geometries) == 1 and isinstance(geometries[0], (tuple, list)):
        geometries = geometries[0]
    if len(geometries) == 0:
        return NO_GEOMETRY
    elif len(geometries) == 1:
        return geometries[0]
    elif all(type(g) == type(geometries[0]) and isinstance(g, PhiTreeNode) for g in geometries):
        attrs = variable_attributes(geometries[0])
        values = {a: math.stack([getattr(g, a) for g in geometries], math.instance(&#39;union&#39;)) for a in attrs}
        return copy_with(geometries[0], **values)
    else:
        base_geometries = ()
        for geometry in geometries:
            base_geometries += geometry.geometries if isinstance(geometry, Union) else (geometry,)
        return Union(base_geometries)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.geom.BaseBox"><code class="flex name class">
<span>class <span class="ident">BaseBox</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base type for box-like geometries.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseBox(Geometry):  # not a Subwoofer
    &#34;&#34;&#34;
    Abstract base type for box-like geometries.
    &#34;&#34;&#34;

    def __eq__(self, other):
        raise NotImplementedError()

    def __hash__(self):
        raise NotImplementedError()

    def __ne__(self, other):
        return not self == other

    @property
    def shape(self):
        raise NotImplementedError()

    @property
    def center(self) -&gt; Tensor:
        raise NotImplementedError()

    def at(self, center: Tensor) -&gt; &#39;BaseBox&#39;:
        return Cuboid(center, self.half_size)

    @property
    def size(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def half_size(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def lower(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def upper(self) -&gt; Tensor:
        raise NotImplementedError(self)

    @property
    def volume(self) -&gt; Tensor:
        return math.prod(self.size, &#39;vector&#39;)

    @property
    def shape_type(self) -&gt; Tensor:
        return math.tensor(&#39;B&#39;)

    def bounding_radius(self):
        return math.vec_length(self.half_size)

    def bounding_half_extent(self):
        return self.size * 0.5

    def global_to_local(self, global_position: Tensor) -&gt; Tensor:
        if math.close(self.lower, 0):
            return global_position / self.size
        else:
            return (global_position - self.lower) / self.size

    def local_to_global(self, local_position):
        return local_position * self.size + self.lower

    def lies_inside(self, location):
        bool_inside = (location &gt;= self.lower) &amp; (location &lt;= self.upper)
        bool_inside = math.all(bool_inside, &#39;vector&#39;)
        bool_inside = math.any(bool_inside, self.shape.instance)  # union for instance dimensions
        return bool_inside

    def approximate_signed_distance(self, location: Tensor or tuple):
        &#34;&#34;&#34;
        Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
        For an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.
        For inside locations it is `-max(abs(l - s))`.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        center = 0.5 * (self.lower + self.upper)
        extent = self.upper - self.lower
        distance = math.abs(location - center) - extent * 0.5
        distance = math.max(distance, &#39;vector&#39;)
        distance = math.min(distance, self.shape.instance)  # union for instance dimensions
        return distance

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        loc_to_center = positions - self.center
        sgn_dist_from_surface = math.abs(loc_to_center) - self.half_size
        if outward:
            # --- get negative distances (particles are inside) towards the nearest boundary and add shift_amount ---
            distances_of_interest = (sgn_dist_from_surface == math.max(sgn_dist_from_surface, &#39;vector&#39;)) &amp; (sgn_dist_from_surface &lt; 0)
            shift = distances_of_interest * (sgn_dist_from_surface - shift_amount)
        else:
            shift = (sgn_dist_from_surface + shift_amount) * (sgn_dist_from_surface &gt; 0)  # get positive distances (particles are outside) and add shift_amount
            shift = math.where(math.abs(shift) &gt; math.abs(loc_to_center), math.abs(loc_to_center), shift)  # ensure inward shift ends at center
        return positions + math.where(loc_to_center &lt; 0, 1, -1) * shift

    def project(self, *dimensions: str):
        &#34;&#34;&#34; Project this box into a lower-dimensional space. &#34;&#34;&#34;
        warnings.warn(&#34;Box.project(dims) is deprecated. Use Box.vector[dims] instead&#34;, DeprecationWarning, stacklevel=2)
        return self.vector[dimensions]

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        uniform = math.random_uniform(self.shape.non_singleton, *shape, math.channel(vector=self.spatial_rank))
        return self.lower + uniform * self.size

    def corner_representation(self) -&gt; &#39;Box&#39;:
        return Box(self.lower, self.upper)

    box = corner_representation

    def center_representation(self) -&gt; &#39;Cuboid&#39;:
        return Cuboid(self.center, self.half_size)

    def contains(self, other: &#39;BaseBox&#39;):
        &#34;&#34;&#34; Tests if the other box lies fully inside this box. &#34;&#34;&#34;
        return np.all(other.lower &gt;= self.lower) and np.all(other.upper &lt;= self.upper)

    def rotated(self, angle) -&gt; Geometry:
        from ._transform import rotate
        return rotate(self, angle)

    def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
        return Cuboid(self.center, self.half_size * factor)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.geom._box.Box</li>
<li>phi.geom._box.Cuboid</li>
<li>phi.geom._box.GridCell</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.BaseBox.center"><code class="name">var <span class="ident">center</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.half_size"><code class="name">var <span class="ident">half_size</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.lower"><code class="name">var <span class="ident">lower</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.shape_type"><code class="name">var <span class="ident">shape_type</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the type (or types) of this geometry as a string <code>Tensor</code>
Boxes return <code>'B'</code>, spheres return <code>'S'</code>, points return <code>'P'</code>.
Returns <code>'?'</code> for unknown types, e.g. a union over multiple types.
Custom types can return their own identifiers.</p>
<h2 id="returns">Returns</h2>
<p>String <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_type(self) -&gt; Tensor:
    return math.tensor(&#39;B&#39;)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.size"><code class="name">var <span class="ident">size</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.upper"><code class="name">var <span class="ident">upper</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self) -&gt; Tensor:
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.volume"><code class="name">var <span class="ident">volume</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Volume of the geometry as <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code>.
The result retains all batch dimensions while instance dimensions are summed over.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.prod(self.size, &#39;vector&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.BaseBox.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phi.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
For an outside location <code>l</code> with the closest surface point <code>s</code>, the distance is <code>max(abs(l - s))</code>.
For inside locations it is <code>-max(abs(l - s))</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor or tuple):
    &#34;&#34;&#34;
    Computes the signed L-infinity norm (manhattan distance) from the location to the nearest side of the box.
    For an outside location `l` with the closest surface point `s`, the distance is `max(abs(l - s))`.
    For inside locations it is `-max(abs(l - s))`.

    Args:
      location: float tensor of shape (batch_size, ..., rank)

    Returns:
      float tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    center = 0.5 * (self.lower + self.upper)
    extent = self.upper - self.lower
    distance = math.abs(location - center) - extent * 0.5
    distance = math.max(distance, &#39;vector&#39;)
    distance = math.min(distance, self.shape.instance)  # union for instance dimensions
    return distance</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phi.math._tensors.Tensor) ‑> phi.geom._box.BaseBox</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;BaseBox&#39;:
    return Cuboid(center, self.half_size)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>:return: float vector</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self):
    return self.size * 0.5</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self):
    return math.vec_length(self.half_size)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.box"><code class="name flex">
<span>def <span class="ident">box</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    return Box(self.lower, self.upper)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.center_representation"><code class="name flex">
<span>def <span class="ident">center_representation</span></span>(<span>self) ‑> phi.geom._box.Cuboid</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_representation(self) -&gt; &#39;Cuboid&#39;:
    return Cuboid(self.center, self.half_size)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, other: <a title="phi.geom.BaseBox" href="#phi.geom.BaseBox">BaseBox</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests if the other box lies fully inside this box.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, other: &#39;BaseBox&#39;):
    &#34;&#34;&#34; Tests if the other box lies fully inside this box. &#34;&#34;&#34;
    return np.all(other.lower &gt;= self.lower) and np.all(other.upper &lt;= self.upper)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.corner_representation"><code class="name flex">
<span>def <span class="ident">corner_representation</span></span>(<span>self) ‑> phi.geom._box.Box</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corner_representation(self) -&gt; &#39;Box&#39;:
    return Box(self.lower, self.upper)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.global_to_local"><code class="name flex">
<span>def <span class="ident">global_to_local</span></span>(<span>self, global_position: phi.math._tensors.Tensor) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def global_to_local(self, global_position: Tensor) -&gt; Tensor:
    if math.close(self.lower, 0):
        return global_position / self.size
    else:
        return (global_position - self.lower) / self.size</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location):
    bool_inside = (location &gt;= self.lower) &amp; (location &lt;= self.upper)
    bool_inside = math.all(bool_inside, &#39;vector&#39;)
    bool_inside = math.any(bool_inside, self.shape.instance)  # union for instance dimensions
    return bool_inside</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.local_to_global"><code class="name flex">
<span>def <span class="ident">local_to_global</span></span>(<span>self, local_position)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def local_to_global(self, local_position):
    return local_position * self.size + self.lower</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, *dimensions: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Project this box into a lower-dimensional space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, *dimensions: str):
    &#34;&#34;&#34; Project this box into a lower-dimensional space. &#34;&#34;&#34;
    warnings.warn(&#34;Box.project(dims) is deprecated. Use Box.vector[dims] instead&#34;, DeprecationWarning, stacklevel=2)
    return self.vector[dimensions]</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, positions: phi.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and box boundaries after shifting</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
    loc_to_center = positions - self.center
    sgn_dist_from_surface = math.abs(loc_to_center) - self.half_size
    if outward:
        # --- get negative distances (particles are inside) towards the nearest boundary and add shift_amount ---
        distances_of_interest = (sgn_dist_from_surface == math.max(sgn_dist_from_surface, &#39;vector&#39;)) &amp; (sgn_dist_from_surface &lt; 0)
        shift = distances_of_interest * (sgn_dist_from_surface - shift_amount)
    else:
        shift = (sgn_dist_from_surface + shift_amount) * (sgn_dist_from_surface &gt; 0)  # get positive distances (particles are outside) and add shift_amount
        shift = math.where(math.abs(shift) &gt; math.abs(loc_to_center), math.abs(loc_to_center), shift)  # ensure inward shift ends at center
    return positions + math.where(loc_to_center &lt; 0, 1, -1) * shift</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>scalar (2d) or vector (3D+) representing delta angle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle) -&gt; Geometry:
    from ._transform import rotate
    return rotate(self, angle)</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phi.math._shape.Shape) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    uniform = math.random_uniform(self.shape.non_singleton, *shape, math.channel(vector=self.spatial_rank))
    return self.lower + uniform * self.size</code></pre>
</details>
</dd>
<dt id="phi.geom.BaseBox.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
    return Cuboid(self.center, self.half_size * factor)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.geom.Box"><code class="flex name class">
<span>class <span class="ident">Box</span></span>
<span>(</span><span>lower: phi.math._tensors.Tensor = None, upper: phi.math._tensors.Tensor = None, **size: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple cuboid defined by location of lower and upper corner in physical space.</p>
<p>Boxes can be constructed either from two positional vector arguments <code>(lower, upper)</code> or by specifying the limits by dimension name as <code>kwargs</code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre>
<p>The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Box['x,y', 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
&gt;&gt;&gt; Box['x,y', :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lower</code></strong></dt>
<dd>physical location of lower corner</dd>
<dt><strong><code>upper</code></strong></dt>
<dd>physical location of upper corner</dd>
<dt><strong><code>**size</code></strong></dt>
<dd>Specify size by dimension, either as <code>int</code> or <code>tuple</code> containing (lower, upper).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Box(BaseBox, metaclass=BoxType):
    &#34;&#34;&#34;
    Simple cuboid defined by location of lower and upper corner in physical space.

    Boxes can be constructed either from two positional vector arguments `(lower, upper)` or by specifying the limits by dimension name as `kwargs`.

    Examples:
        &gt;&gt;&gt; Box(x=1, y=1)  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box(x=(None, 1), y=(0, None)  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.

        The slicing constructor was updated in version 2.2 and now requires the dimension order as the first argument.

        &gt;&gt;&gt; Box[&#39;x,y&#39;, 0:1, 0:1]  # creates a two-dimensional unit box with `lower=(0, 0)` and `upper=(1, 1)`.
        &gt;&gt;&gt; Box[&#39;x,y&#39;, :1, 0:]  # creates a Box with `lower=(-inf, 0)` and `upper=(1, inf)`.
    &#34;&#34;&#34;

    def __init__(self, lower: Tensor = None, upper: Tensor = None, **size: int or Tensor):
        &#34;&#34;&#34;
        Args:
          lower: physical location of lower corner
          upper: physical location of upper corner
          **size: Specify size by dimension, either as `int` or `tuple` containing (lower, upper).
        &#34;&#34;&#34;
        if lower is not None:
            assert isinstance(lower, Tensor), f&#34;lower must be a Tensor but got {type(lower)}&#34;
            assert &#39;vector&#39; in lower.shape, &#34;lower must have a vector dimension&#34;
            assert lower.vector.item_names is not None, &#34;vector dimension of lower must list spatial dimension order&#34;
            self._lower = lower
        if upper is not None:
            assert isinstance(upper, Tensor), f&#34;upper must be a Tensor but got {type(upper)}&#34;
            assert &#39;vector&#39; in upper.shape, &#34;lower must have a vector dimension&#34;
            assert upper.vector.item_names is not None, &#34;vector dimension of lower must list spatial dimension order&#34;
            self._upper = upper
        else:
            lower = []
            upper = []
            for item in size.values():
                if isinstance(item, (tuple, list)):
                    assert len(item) == 2, f&#34;Box kwargs must be either dim=upper or dim=(lower,upper) but got {item}&#34;
                    lo, up = item
                    lower.append(lo)
                    upper.append(up)
                elif item is None:
                    lower.append(-INF)
                    upper.append(INF)
                else:
                    lower.append(0)
                    upper.append(item)
            lower = [-INF if l is None else l for l in lower]
            upper = [INF if u is None else u for u in upper]
            self._upper = math.wrap(upper, math.channel(vector=tuple(size.keys())))
            self._lower = math.wrap(lower, math.channel(vector=tuple(size.keys())))
        vector_shape = self._lower.shape &amp; self._upper.shape
        self._lower = math.expand(self._lower, vector_shape)
        self._upper = math.expand(self._upper, vector_shape)
        if self.size.vector.item_names is None:
            warnings.warn(&#34;Creating a Box without item names prevents certain operations like project()&#34;, DeprecationWarning, stacklevel=2)

    def __getitem__(self, item):
        item = _keep_vector(slicing_dict(self, item))
        return Box(self._lower[item], self._upper[item])

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        if all(isinstance(v, Box) for v in values):
            return NotImplemented  # stack attributes
        else:
            return Geometry.__stack__(values, dim, **kwargs)

    def __eq__(self, other):
        if self._lower is None and self._upper is None:
            return isinstance(other, Box)
        return isinstance(other, BaseBox)\
               and set(self.shape) == set(other.shape)\
               and self.size.shape.get_size(&#39;vector&#39;) == other.size.shape.get_size(&#39;vector&#39;)\
               and math.close(self._lower, other.lower)\
               and math.close(self._upper, other.upper)

    def without(self, dims: Tuple[str, ...]):
        remaining = list(self.shape.get_item_names(&#39;vector&#39;))
        for dim in dims:
            if dim in remaining:
                remaining.remove(dim)
        return self.vector[remaining]

    def __hash__(self):
        return hash(self._upper)

    def __variable_attrs__(self):
        return &#39;_lower&#39;, &#39;_upper&#39;

    @property
    def shape(self):
        if self._lower is None or self._upper is None:
            return None
        return self._lower.shape &amp; self._upper.shape

    @property
    def lower(self):
        return self._lower

    @property
    def upper(self):
        return self._upper

    @property
    def size(self):
        return self.upper - self.lower

    @property
    def center(self):
        return 0.5 * (self.lower + self.upper)

    @property
    def half_size(self):
        return self.size * 0.5

    def shifted(self, delta, **delta_by_dim):
        return Box(self.lower + delta, self.upper + delta)

    def __mul__(self, other):
        if not isinstance(other, Box):
            return NotImplemented
        lower = self._lower.vector.unstack(self.spatial_rank) + other._lower.vector.unstack(other.spatial_rank)
        upper = self._upper.vector.unstack(self.spatial_rank) + other._upper.vector.unstack(other.spatial_rank)
        names = self._upper.vector.item_names + other._upper.vector.item_names
        lower = math.stack(lower, math.channel(vector=names))
        upper = math.stack(upper, math.channel(vector=names))
        return Box(lower, upper)

    def __repr__(self):
        if self.shape.non_channel.volume == 1:
            item_names = self.size.vector.item_names
            if item_names:
                return f&#34;Box({&#39;, &#39;.join([f&#39;{dim}=({lo}, {up})&#39; for dim, lo, up in zip(item_names, self._lower, self._upper)])})&#34;
            else:  # deprecated
                return &#39;Box[%s at %s]&#39; % (&#39;x&#39;.join([str(x) for x in self.size.numpy().flatten()]), &#39;,&#39;.join([str(x) for x in self.lower.numpy().flatten()]))
        else:
            return f&#39;Box[shape={self.shape}]&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Box.center"><code class="name">var <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return 0.5 * (self.lower + self.upper)</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.half_size"><code class="name">var <span class="ident">half_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self.size * 0.5</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self):
    return self._lower</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    if self._lower is None or self._upper is None:
        return None
    return self._lower.shape &amp; self._upper.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.upper - self.lower</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.upper"><code class="name">var <span class="ident">upper</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self):
    return self._upper</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Box.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta, **delta_by_dim)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta, **delta_by_dim):
    return Box(self.lower + delta, self.upper + delta)</code></pre>
</details>
</dd>
<dt id="phi.geom.Box.without"><code class="name flex">
<span>def <span class="ident">without</span></span>(<span>self, dims: Tuple[str, ...])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without(self, dims: Tuple[str, ...]):
    remaining = list(self.shape.get_item_names(&#39;vector&#39;))
    for dim in dims:
        if dim in remaining:
            remaining.remove(dim)
    return self.vector[remaining]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.geom.Cuboid"><code class="flex name class">
<span>class <span class="ident">Cuboid</span></span>
<span>(</span><span>center: phi.math._tensors.Tensor = 0, half_size: float = None, **size: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Box specified by center position and half size.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cuboid(BaseBox):
    &#34;&#34;&#34;
    Box specified by center position and half size.
    &#34;&#34;&#34;

    def __init__(self,
                 center: Tensor = 0,
                 half_size: float or Tensor = None,
                 **size: float or Tensor):
        if half_size is not None:
            assert isinstance(half_size, Tensor), &#34;half_size must be a Tensor&#34;
            assert &#39;vector&#39; in half_size.shape, f&#34;Cuboid size must have a &#39;vector&#39; dimension.&#34;
            assert half_size.shape.get_item_names(&#39;vector&#39;) is not None, f&#34;Vector dimension must list spatial dimensions as item names. Use the syntax Cuboid(x=x, y=y) to assign names.&#34;
            self._half_size = half_size
        else:
            self._half_size = math.wrap(tuple(size.values()), math.channel(vector=tuple(size.keys()))) * 0.5
        center = wrap(center)
        if &#39;vector&#39; not in center.shape or center.shape.get_item_names(&#39;vector&#39;) is None:
            center = math.expand(center, channel(self._half_size))
        self._center = center


    def __eq__(self, other):
        if self._center is None and self._half_size is None:
            return isinstance(other, Cuboid)
        return isinstance(other, BaseBox)\
               and set(self.shape) == set(other.shape)\
               and math.close(self._center, other.center)\
               and math.close(self._half_size, other.half_size)

    def __hash__(self):
        return hash(self._center)

    def __repr__(self):
        return f&#34;Cuboid(center={self._center}, half_size={self._half_size})&#34;

    def __getitem__(self, item):
        item = _keep_vector(slicing_dict(self, item))
        return Cuboid(self._center[item], self._half_size[item])

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        if all(isinstance(v, Cuboid) for v in values):
            return Cuboid(math.stack([v.center for v in values], dim, **kwargs), math.stack([v.half_size for v in values], dim, **kwargs))
        else:
            return Geometry.__stack__(values, dim, **kwargs)

    def __variable_attrs__(self):
        return &#39;_center&#39;, &#39;_half_size&#39;

    @property
    def center(self):
        return self._center

    @property
    def half_size(self):
        return self._half_size

    @property
    def shape(self):
        if self._center is None or self._half_size is None:
            return None
        return self._center.shape &amp; self._half_size.shape

    @property
    def size(self):
        return 2 * self.half_size

    @property
    def lower(self):
        return self.center - self.half_size

    @property
    def upper(self):
        return self.center + self.half_size

    def shifted(self, delta, **delta_by_dim) -&gt; &#39;Cuboid&#39;:
        return Cuboid(self._center + delta, self._half_size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Cuboid.center"><code class="name">var <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self._center</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.half_size"><code class="name">var <span class="ident">half_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self._half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self):
    return self.center - self.half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    if self._center is None or self._half_size is None:
        return None
    return self._center.shape &amp; self._half_size.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return 2 * self.half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.Cuboid.upper"><code class="name">var <span class="ident">upper</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self):
    return self.center + self.half_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Cuboid.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta, **delta_by_dim) ‑> phi.geom._box.Cuboid</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta, **delta_by_dim) -&gt; &#39;Cuboid&#39;:
    return Cuboid(self._center + delta, self._half_size)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.geom.Geometry"><code class="flex name class">
<span>class <span class="ident">Geometry</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for N-dimensional shapes.</p>
<p>Main implementing classes:</p>
<ul>
<li>Sphere</li>
<li>box family: box (generator), Box, Cuboid, BaseBox</li>
</ul>
<p>All geometry objects support batching.
Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
All batch dimensions are listed in Geometry.shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geometry:
    &#34;&#34;&#34;
    Abstract base class for N-dimensional shapes.

    Main implementing classes:

    * Sphere
    * box family: box (generator), Box, Cuboid, BaseBox

    All geometry objects support batching.
    Thereby any parameter defining the geometry can be varied along arbitrary batch dims.
    All batch dimensions are listed in Geometry.shape.
    &#34;&#34;&#34;

    @property
    def center(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Center location in single channel dimension.
        &#34;&#34;&#34;
        raise NotImplementedError(self)

    @property
    def shape(self) -&gt; Shape:
        &#34;&#34;&#34;
        The `shape` of a `Geometry` consists of the following dimensions:

        * A single *channel* dimension called `&#39;vector&#39;` specifying the physical space
        * Instance dimensions denote that this geometry consists of multiple copies in the same space
        * Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space
        * Batch dimensions indicate non-interacting versions of this geometry for parallelization only.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def volume(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Volume of the geometry as `phi.math.Tensor`.
        The result retains all batch dimensions while instance dimensions are summed over.
        &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def shape_type(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns the type (or types) of this geometry as a string `Tensor`
        Boxes return `&#39;B&#39;`, spheres return `&#39;S&#39;`, points return `&#39;P&#39;`.
        Returns `&#39;?&#39;` for unknown types, e.g. a union over multiple types.
        Custom types can return their own identifiers.

        Returns:
            String `Tensor`
        &#34;&#34;&#34;
        raise NotImplementedError()

    def unstack(self, dimension: str) -&gt; tuple:
        &#34;&#34;&#34;
        Unstacks this Geometry along the given dimension.
        The shapes of the returned geometries are reduced by `dimension`.

        Args:
            dimension: dimension along which to unstack

        Returns:
            geometries: tuple of length equal to `geometry.shape.get_size(dimension)`
        &#34;&#34;&#34;
        return math.unstack(self, dimension)

    @property
    def spatial_rank(self) -&gt; int:
        &#34;&#34;&#34; Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc. &#34;&#34;&#34;
        return self.center.shape.get_size(&#39;vector&#39;)

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        &#34;&#34;&#34;
        Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.

        When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          bool tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_signed_distance(self, location: Tensor or tuple) -&gt; Tensor:
        &#34;&#34;&#34;
        Computes the approximate distance from location to the surface of the geometry.
        Locations outside return positive values, inside negative values and zero exactly at the boundary.

        The exact distance metric used depends on the geometry.
        The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
        The distance metric is differentiable and its gradients are bounded at every point in space.

        When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
        This also holds for negative distances.

        Args:
          location: float tensor of shape (batch_size, ..., rank)
          location: Tensor:

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def approximate_fraction_inside(self, other_geometry: &#39;Geometry&#39;, balance: Tensor or Number = 0.5) -&gt; Tensor:
        &#34;&#34;&#34;
        Computes the approximate overlap between the geometry and a small other geometry.
        Returns 1.0 if `other_geometry` is fully enclosed in this geometry and 0.0 if there is no overlap.
        Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of `other_geometry`.

        To call this method on batches of geometries of same shape, pass a batched Geometry instance.
        The result tensor will match the batch shape of `other_geometry`.

        The result may only be accurate in special cases.
        The given geometries may be approximated as spheres or boxes using `bounding_radius()` and `bounding_half_extent()`.

        The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using `approximate_signed_distance()`.

        Args:
            other_geometry: `Geometry` or geometry batch for which to compute the overlap with `self`.
            balance: Mid-level between 0 and 1, default 0.5.
                This value is returned when exactly half of `other_geometry` lies inside `self`.
                `0.5 &lt; balance &lt;= 1` makes `self` seem larger while `0 &lt;= balance &lt; 0.5`makes `self` seem smaller.

        Returns:
          fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).

        &#34;&#34;&#34;
        assert isinstance(other_geometry, Geometry)
        radius = other_geometry.bounding_radius()
        location = other_geometry.center
        distance = self.approximate_signed_distance(location)
        inside_fraction = balance - distance / radius
        inside_fraction = math.clip(inside_fraction, 0, 1)
        return inside_fraction

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        &#34;&#34;&#34;
        Shifts positions either into or out of geometry.

        Args:
            positions: Tensor holding positions to shift
            outward: Flag for indicating inward (False) or outward (True) shift
            shift_amount: Minimum distance between positions and box boundaries after shifting

        Returns:
            Tensor holding shifted positions
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        &#34;&#34;&#34;
        Samples uniformly distributed random points inside this volume.

        Args:
            *shape: How many points to sample per individual geometry.

        Returns:
            `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_radius(self) -&gt; Tensor:
        &#34;&#34;&#34;
        Returns the radius of a Sphere object that fully encloses this geometry.
        The sphere is centered at the center of this geometry.

        :return: radius of type float

        Args:

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_half_extent(self) -&gt; Tensor:
        &#34;&#34;&#34;
        The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
        Each component is non-negative.

        Let the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).
        Then, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).

        :return: float vector

        Args:

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def bounding_box(self) -&gt; &#39;BaseBox&#39;:
        &#34;&#34;&#34;
        Returns the approximately smallest axis-aligned box that contains this `Geometry`.
        The center of the box may not be equal to `self.center`.

        Returns:
            `Box` or `Cuboid` that fully contains this `Geometry`.
        &#34;&#34;&#34;
        from ._box import Cuboid
        return Cuboid(self.center, half_size=self.bounding_half_extent())

    def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a translated version of this geometry.

        See Also:
            `Geometry.at()`.

        Args:
          delta: direction vector
          delta: Tensor:

        Returns:
          Geometry: shifted geometry

        &#34;&#34;&#34;
        return self.at(self.center + delta)

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a copy of this `Geometry` with the center at `center`.
        This is equal to calling `self @ center`.

        See Also:
            `Geometry.shifted()`.

        Args:
            center: New center as `Tensor`.

        Returns:
            `Geometry`.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __matmul__(self, other):
        return self.at(other)

    def rotated(self, angle: float or Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Returns a rotated version of this geometry.
        The geometry is rotated about its center point.

        Args:
          angle: scalar (2d) or vector (3D+) representing delta angle

        Returns:
            Rotated `Geometry`
        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
        &#34;&#34;&#34;
        Scales each individual geometry by `factor`.
        The individual `center` points act as pivots for the operation.

        Args:
            factor:

        Returns:

        &#34;&#34;&#34;
        raise NotImplementedError(self.__class__)

    def __invert__(self):
        return _InvertedGeometry(self)

    def __eq__(self, other):
        &#34;&#34;&#34;
        Slow equality check.
        Unlike `==`, this method compares all tensor elements to check whether they are equal.
        Use `==` for a faster check which only checks whether the referenced tensors are the same.

        See Also:
            `shallow_equals()`
        &#34;&#34;&#34;
        if self is other:
            return True
        if not isinstance(other, type(self)):
            return False
        if self.shape != other.shape:
            return False
        c1 = {a: getattr(self, a) for a in variable_attributes(self)}
        c2 = {a: getattr(other, a) for a in variable_attributes(self)}
        for c in c1.keys():
            if c1[c] is not c2[c] and math.any(c1[c] != c2[c]):
                return False
        return True

    def shallow_equals(self, other):
        &#34;&#34;&#34;
        Quick equality check.
        May return `False` even if `other == self`.
        However, if `True` is returned, the geometries are guaranteed to be equal.

        The `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.
        &#34;&#34;&#34;
        if self is other:
            return True
        if not isinstance(other, type(self)):
            return False
        if self.shape != other.shape:
            return False
        c1 = {a: getattr(self, a) for a in variable_attributes(self)}
        c2 = {a: getattr(other, a) for a in variable_attributes(self)}
        for c in c1.keys():
            if c1[c] is not c2[c]:
                return False
        return True

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        if all(type(v) == type(values[0]) for v in values):
            return NotImplemented  # let attributes be stacked
        else:
            from ._stack import GeometryStack
            return GeometryStack(math.layout(values, dim))

    def __flatten__(self, flat_dim: Shape, flatten_batch: bool, **kwargs) -&gt; &#39;Geometry&#39;:
        dims = self.shape.without(&#39;vector&#39;)
        if not flatten_batch:
            dims = dims.non_batch
        return math.pack_dims(self, dims, flat_dim, **kwargs)

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        raise NotImplementedError(self.__class__)

    def __repr__(self):
        return f&#34;{self.__class__.__name__}{self.shape}&#34;

    def __getitem__(self, item):
        raise NotImplementedError
        # assert isinstance(item, dict), &#34;Index must be dict of type {dim: slice/int}.&#34;
        # item = {dim: sel for dim, sel in item.items() if dim != &#39;vector&#39;}
        # attrs = {a: getattr(self, a)[item] for a in variable_attributes(self)}
        # return copy_with(self, **attrs)

    def __getattr__(self, name: str) -&gt; BoundDim:
        return BoundDim(self, name)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.Point</li>
<li>phi.geom._geom._InvertedGeometry</li>
<li>phi.geom._geom._NoGeometry</li>
<li>phi.geom._sphere.Sphere</li>
<li>phi.geom._stack.GeometryStack</li>
<li>phi.geom._transform.RotatedGeometry</li>
<li>phi.geom._transform._EmbeddedGeometry</li>
<li>phi.geom._union.Union</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Geometry.center"><code class="name">var <span class="ident">center</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Center location in single channel dimension.
    &#34;&#34;&#34;
    raise NotImplementedError(self)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.shape"><code class="name">var <span class="ident">shape</span> : phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    &#34;&#34;&#34;
    The `shape` of a `Geometry` consists of the following dimensions:

    * A single *channel* dimension called `&#39;vector&#39;` specifying the physical space
    * Instance dimensions denote that this geometry consists of multiple copies in the same space
    * Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space
    * Batch dimensions indicate non-interacting versions of this geometry for parallelization only.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.shape_type"><code class="name">var <span class="ident">shape_type</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the type (or types) of this geometry as a string <code>Tensor</code>
Boxes return <code>'B'</code>, spheres return <code>'S'</code>, points return <code>'P'</code>.
Returns <code>'?'</code> for unknown types, e.g. a union over multiple types.
Custom types can return their own identifiers.</p>
<h2 id="returns">Returns</h2>
<p>String <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_type(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns the type (or types) of this geometry as a string `Tensor`
    Boxes return `&#39;B&#39;`, spheres return `&#39;S&#39;`, points return `&#39;P&#39;`.
    Returns `&#39;?&#39;` for unknown types, e.g. a union over multiple types.
    Custom types can return their own identifiers.

    Returns:
        String `Tensor`
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.spatial_rank"><code class="name">var <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    &#34;&#34;&#34; Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc. &#34;&#34;&#34;
    return self.center.shape.get_size(&#39;vector&#39;)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.volume"><code class="name">var <span class="ident">volume</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Volume of the geometry as <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code>.
The result retains all batch dimensions while instance dimensions are summed over.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Volume of the geometry as `phi.math.Tensor`.
    The result retains all batch dimensions while instance dimensions are summed over.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Geometry.approximate_fraction_inside"><code class="name flex">
<span>def <span class="ident">approximate_fraction_inside</span></span>(<span>self, other_geometry: <a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a>, balance: phi.math._tensors.Tensor = 0.5) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate overlap between the geometry and a small other geometry.
Returns 1.0 if <code>other_geometry</code> is fully enclosed in this geometry and 0.0 if there is no overlap.
Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of <code>other_geometry</code>.</p>
<p>To call this method on batches of geometries of same shape, pass a batched Geometry instance.
The result tensor will match the batch shape of <code>other_geometry</code>.</p>
<p>The result may only be accurate in special cases.
The given geometries may be approximated as spheres or boxes using <code>bounding_radius()</code> and <code>bounding_half_extent()</code>.</p>
<p>The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using <code>approximate_signed_distance()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>other_geometry</code></strong></dt>
<dd><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> or geometry batch for which to compute the overlap with <code>self</code>.</dd>
<dt><strong><code>balance</code></strong></dt>
<dd>Mid-level between 0 and 1, default 0.5.
This value is returned when exactly half of <code>other_geometry</code> lies inside <code>self</code>.
<code>0.5 &lt; balance &lt;= 1</code> makes <code>self</code> seem larger while <code>0 &lt;= balance &lt; 0.5</code>makes <code>self</code> seem smaller.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_fraction_inside(self, other_geometry: &#39;Geometry&#39;, balance: Tensor or Number = 0.5) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes the approximate overlap between the geometry and a small other geometry.
    Returns 1.0 if `other_geometry` is fully enclosed in this geometry and 0.0 if there is no overlap.
    Close to the surface of this geometry, the fraction filled is differentiable w.r.t. the location and size of `other_geometry`.

    To call this method on batches of geometries of same shape, pass a batched Geometry instance.
    The result tensor will match the batch shape of `other_geometry`.

    The result may only be accurate in special cases.
    The given geometries may be approximated as spheres or boxes using `bounding_radius()` and `bounding_half_extent()`.

    The default implementation of this method approximates other_geometry as a Sphere and computes the fraction using `approximate_signed_distance()`.

    Args:
        other_geometry: `Geometry` or geometry batch for which to compute the overlap with `self`.
        balance: Mid-level between 0 and 1, default 0.5.
            This value is returned when exactly half of `other_geometry` lies inside `self`.
            `0.5 &lt; balance &lt;= 1` makes `self` seem larger while `0 &lt;= balance &lt; 0.5`makes `self` seem smaller.

    Returns:
      fraction of cell volume lying inside the geometry. float tensor of shape (other_geometry.batch_shape, 1).

    &#34;&#34;&#34;
    assert isinstance(other_geometry, Geometry)
    radius = other_geometry.bounding_radius()
    location = other_geometry.center
    distance = self.approximate_signed_distance(location)
    inside_fraction = balance - distance / radius
    inside_fraction = math.clip(inside_fraction, 0, 1)
    return inside_fraction</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phi.math._tensors.Tensor) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
<dt><strong><code>location</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor or tuple) -&gt; Tensor:
    &#34;&#34;&#34;
    Computes the approximate distance from location to the surface of the geometry.
    Locations outside return positive values, inside negative values and zero exactly at the boundary.

    The exact distance metric used depends on the geometry.
    The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
    The distance metric is differentiable and its gradients are bounded at every point in space.

    When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
    This also holds for negative distances.

    Args:
      location: float tensor of shape (batch_size, ..., rank)
      location: Tensor:

    Returns:
      float tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phi.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Returns a copy of this `Geometry` with the center at `center`.
    This is equal to calling `self @ center`.

    See Also:
        `Geometry.shifted()`.

    Args:
        center: New center as `Tensor`.

    Returns:
        `Geometry`.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.bounding_box"><code class="name flex">
<span>def <span class="ident">bounding_box</span></span>(<span>self) ‑> <a title="phi.geom.BaseBox" href="#phi.geom.BaseBox">BaseBox</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the approximately smallest axis-aligned box that contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.
The center of the box may not be equal to <code>self.center</code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code> or <code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid</a></code> that fully contains this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_box(self) -&gt; &#39;BaseBox&#39;:
    &#34;&#34;&#34;
    Returns the approximately smallest axis-aligned box that contains this `Geometry`.
    The center of the box may not be equal to `self.center`.

    Returns:
        `Box` or `Cuboid` that fully contains this `Geometry`.
    &#34;&#34;&#34;
    from ._box import Cuboid
    return Cuboid(self.center, half_size=self.bounding_half_extent())</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>:return: float vector</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    &#34;&#34;&#34;
    The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
    Each component is non-negative.

    Let the bounding half-extent have value `e` in dimension `d` (`extent[...,d] = e`).
    Then, no point of the geometry lies further away from its center point than `e` along `d` (in both axis directions).

    :return: float vector

    Args:

    Returns:

    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    &#34;&#34;&#34;
    Returns the radius of a Sphere object that fully encloses this geometry.
    The sphere is centered at the center of this geometry.

    :return: radius of type float

    Args:

    Returns:

    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phi.math._tensors.Tensor) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    &#34;&#34;&#34;
    Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.

    When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.

    Args:
      location: float tensor of shape (batch_size, ..., rank)

    Returns:
      bool tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, positions: phi.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and box boundaries after shifting</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
    &#34;&#34;&#34;
    Shifts positions either into or out of geometry.

    Args:
        positions: Tensor holding positions to shift
        outward: Flag for indicating inward (False) or outward (True) shift
        shift_amount: Minimum distance between positions and box boundaries after shifting

    Returns:
        Tensor holding shifted positions
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle: float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>scalar (2d) or vector (3D+) representing delta angle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle: float or Tensor) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Returns a rotated version of this geometry.
    The geometry is rotated about its center point.

    Args:
      angle: scalar (2d) or vector (3D+) representing delta angle

    Returns:
        Rotated `Geometry`
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phi.math._shape.Shape) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    &#34;&#34;&#34;
    Samples uniformly distributed random points inside this volume.

    Args:
        *shape: How many points to sample per individual geometry.

    Returns:
        `Tensor` containing all dimensions from `Geometry.shape`, `shape` as well as a `channel` dimension `vector` matching the dimensionality of this `Geometry`.
    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Scales each individual geometry by `factor`.
    The individual `center` points act as pivots for the operation.

    Args:
        factor:

    Returns:

    &#34;&#34;&#34;
    raise NotImplementedError(self.__class__)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shallow_equals(self, other):
    &#34;&#34;&#34;
    Quick equality check.
    May return `False` even if `other == self`.
    However, if `True` is returned, the geometries are guaranteed to be equal.

    The `shallow_equals()` check does not compare all tensor elements but merely checks whether the same tensors are referenced.
    &#34;&#34;&#34;
    if self is other:
        return True
    if not isinstance(other, type(self)):
        return False
    if self.shape != other.shape:
        return False
    c1 = {a: getattr(self, a) for a in variable_attributes(self)}
    c2 = {a: getattr(other, a) for a in variable_attributes(self)}
    for c in c1.keys():
        if c1[c] is not c2[c]:
            return False
    return True</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phi.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor) -&gt; &#39;Geometry&#39;:
    &#34;&#34;&#34;
    Returns a translated version of this geometry.

    See Also:
        `Geometry.at()`.

    Args:
      delta: direction vector
      delta: Tensor:

    Returns:
      Geometry: shifted geometry

    &#34;&#34;&#34;
    return self.at(self.center + delta)</code></pre>
</details>
</dd>
<dt id="phi.geom.Geometry.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstacks this Geometry along the given dimension.
The shapes of the returned geometries are reduced by <code>dimension</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>dimension along which to unstack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geometries</code></dt>
<dd>tuple of length equal to <code>geometry.shape.get_size(dimension)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    &#34;&#34;&#34;
    Unstacks this Geometry along the given dimension.
    The shapes of the returned geometries are reduced by `dimension`.

    Args:
        dimension: dimension along which to unstack

    Returns:
        geometries: tuple of length equal to `geometry.shape.get_size(dimension)`
    &#34;&#34;&#34;
    return math.unstack(self, dimension)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.geom.GridCell"><code class="flex name class">
<span>class <span class="ident">GridCell</span></span>
<span>(</span><span>resolution: phi.math._shape.Shape, bounds: phi.geom._box.BaseBox)</span>
</code></dt>
<dd>
<div class="desc"><p>An instance of GridCell represents all cells of a regular grid as a batch of boxes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GridCell(BaseBox):
    &#34;&#34;&#34;
    An instance of GridCell represents all cells of a regular grid as a batch of boxes.
    &#34;&#34;&#34;

    def __init__(self, resolution: math.Shape, bounds: BaseBox):
        assert resolution.spatial_rank == resolution.rank, f&#34;resolution must be purely spatial but got {resolution}&#34;
        assert resolution.spatial_rank == bounds.spatial_rank, f&#34;bounds must match dimensions of resolution but got {bounds} for resolution {resolution}&#34;
        self._resolution = resolution
        self._bounds = bounds
        self._shape = resolution &amp; bounds.shape.non_spatial

    @property
    def resolution(self):
        return self._resolution

    @property
    def bounds(self):
        return self._bounds

    @property
    def spatial_rank(self) -&gt; int:
        return self._resolution.spatial_rank

    @property
    def center(self):
        local_coords = math.meshgrid(**{dim.name: math.linspace(0.5 / dim.size, 1 - 0.5 / dim.size, dim) for dim in self.resolution})
        points = self.bounds.local_to_global(local_coords)
        return points

    @property
    def grid_size(self):
        return self._bounds.size

    @property
    def size(self):
        return self.bounds.size / math.wrap(self.resolution.sizes)

    @property
    def dx(self):
        return self.bounds.size / self.resolution

    @property
    def lower(self):
        return self.center - self.half_size

    @property
    def upper(self):
        return self.center + self.half_size

    @property
    def half_size(self):
        return self.bounds.size / self.resolution.sizes / 2

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        bounds = self._bounds
        dx = self.size
        gather_dict = {}
        for dim, selection in item.items():
            if dim in self._resolution:
                if isinstance(selection, int):
                    start = selection
                    stop = selection + 1
                elif isinstance(selection, slice):
                    start = selection.start or 0
                    if start &lt; 0:
                        start += self.resolution.get_size(dim)
                    stop = selection.stop or self.resolution.get_size(dim)
                    if stop &lt; 0:
                        stop += self.resolution.get_size(dim)
                    assert selection.step is None or selection.step == 1
                else:
                    raise ValueError(f&#34;Illegal selection: {item}&#34;)
                dim_mask = math.wrap(self.resolution.mask(dim))
                lower = bounds.lower + start * dim_mask * dx
                upper = bounds.upper + (stop - self.resolution.get_size(dim)) * dim_mask * dx
                bounds = Box(lower, upper)
                gather_dict[dim] = slice(start, stop)
        resolution = self._resolution.after_gather(gather_dict)
        return GridCell(resolution, bounds[{d: s for d, s in item.items() if d != &#39;vector&#39;}])

    def __pack_dims__(self, dims: Tuple[str, ...], packed_dim: Shape, pos: int or None, **kwargs) -&gt; &#39;Cuboid&#39;:
        return math.pack_dims(self.center_representation(), dims, packed_dim, pos, **kwargs)

    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Geometry&#39;:
        from ._stack import GeometryStack
        return GeometryStack(math.layout(values, dim))

    def list_cells(self, dim_name):
        center = math.pack_dims(self.center, self._shape.spatial.names, dim_name)
        return Cuboid(center, self.half_size)

    def stagger(self, dim: str, lower: bool, upper: bool):
        dim_mask = np.array(self.resolution.mask(dim))
        unit = self.bounds.size / self.resolution * dim_mask
        bounds = Box(self.bounds.lower + unit * (-0.5 if lower else 0.5), self.bounds.upper + unit * (0.5 if upper else -0.5))
        ext_res = self.resolution.sizes + dim_mask * (int(lower) + int(upper) - 1)
        return GridCell(self.resolution.with_sizes(ext_res), bounds)

    def padded(self, widths: dict):
        resolution, bounds = self.resolution, self.bounds
        for dim, (lower, upper) in widths.items():
            masked_dx = self.dx * math.dim_mask(self.resolution, dim)
            resolution = resolution.with_dim_size(dim, self.resolution.get_size(dim) + lower + upper)
            bounds = Box(bounds.lower - masked_dx * lower, bounds.upper + masked_dx * upper)
        return GridCell(resolution, bounds)

    # def face_centers(self, staggered_name=&#39;staggered&#39;):
    #     face_centers = [self.extend_symmetric(dim).center for dim in self.shape.spatial.names]
    #     return math.channel_stack(face_centers, staggered_name)

    @property
    def shape(self):
        return self._shape

    def shifted(self, delta: Tensor, **delta_by_dim) -&gt; BaseBox:
        # delta += math.padded_stack()
        if delta.shape.spatial_rank == 0:
            return GridCell(self.resolution, self.bounds.shifted(delta))
        else:
            center = self.center + delta
            return Cuboid(center, self.half_size)

    def rotated(self, angle) -&gt; Geometry:
        raise NotImplementedError(&#34;Grids cannot be rotated. Use center_representation() to convert it to Cuboids first.&#34;)

    def __eq__(self, other):
        return isinstance(other, GridCell) and self._bounds == other._bounds and self._resolution == other._resolution

    def shallow_equals(self, other):
        return self == other

    def __hash__(self):
        return hash(self._resolution) + hash(self._bounds)

    def __repr__(self):
        return f&#34;{self._resolution}, bounds={self._bounds}&#34;

    def __variable_attrs__(self):
        return &#39;_center&#39;, &#39;_half_size&#39;

    def __with_attrs__(self, **attrs):
        return copy_with(self.center_representation(), **attrs)

    @property
    def _center(self):
        return self.center

    @property
    def _half_size(self):
        return self.half_size</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._box.BaseBox</li>
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.GridCell.bounds"><code class="name">var <span class="ident">bounds</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bounds(self):
    return self._bounds</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.center"><code class="name">var <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    local_coords = math.meshgrid(**{dim.name: math.linspace(0.5 / dim.size, 1 - 0.5 / dim.size, dim) for dim in self.resolution})
    points = self.bounds.local_to_global(local_coords)
    return points</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.dx"><code class="name">var <span class="ident">dx</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dx(self):
    return self.bounds.size / self.resolution</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.grid_size"><code class="name">var <span class="ident">grid_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def grid_size(self):
    return self._bounds.size</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.half_size"><code class="name">var <span class="ident">half_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def half_size(self):
    return self.bounds.size / self.resolution.sizes / 2</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.lower"><code class="name">var <span class="ident">lower</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lower(self):
    return self.center - self.half_size</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.resolution"><code class="name">var <span class="ident">resolution</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution(self):
    return self._resolution</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    return self._shape</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return self.bounds.size / math.wrap(self.resolution.sizes)</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.spatial_rank"><code class="name">var <span class="ident">spatial_rank</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of spatial dimensions of the geometry, 1 = 1D, 2 = 2D, 3 = 3D, etc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_rank(self) -&gt; int:
    return self._resolution.spatial_rank</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.upper"><code class="name">var <span class="ident">upper</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def upper(self):
    return self.center + self.half_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.GridCell.list_cells"><code class="name flex">
<span>def <span class="ident">list_cells</span></span>(<span>self, dim_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_cells(self, dim_name):
    center = math.pack_dims(self.center, self._shape.spatial.names, dim_name)
    return Cuboid(center, self.half_size)</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.padded"><code class="name flex">
<span>def <span class="ident">padded</span></span>(<span>self, widths: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def padded(self, widths: dict):
    resolution, bounds = self.resolution, self.bounds
    for dim, (lower, upper) in widths.items():
        masked_dx = self.dx * math.dim_mask(self.resolution, dim)
        resolution = resolution.with_dim_size(dim, self.resolution.get_size(dim) + lower + upper)
        bounds = Box(bounds.lower - masked_dx * lower, bounds.upper + masked_dx * upper)
    return GridCell(resolution, bounds)</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>scalar (2d) or vector (3D+) representing delta angle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle) -&gt; Geometry:
    raise NotImplementedError(&#34;Grids cannot be rotated. Use center_representation() to convert it to Cuboids first.&#34;)</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.shallow_equals"><code class="name flex">
<span>def <span class="ident">shallow_equals</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Quick equality check.
May return <code>False</code> even if <code>other == self</code>.
However, if <code>True</code> is returned, the geometries are guaranteed to be equal.</p>
<p>The <code>shallow_equals()</code> check does not compare all tensor elements but merely checks whether the same tensors are referenced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shallow_equals(self, other):
    return self == other</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.shifted"><code class="name flex">
<span>def <span class="ident">shifted</span></span>(<span>self, delta: phi.math._tensors.Tensor, **delta_by_dim) ‑> phi.geom._box.BaseBox</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a translated version of this geometry.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">Geometry.at()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delta</code></strong></dt>
<dd>direction vector</dd>
<dt><strong><code>delta</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></dt>
<dd>shifted geometry</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shifted(self, delta: Tensor, **delta_by_dim) -&gt; BaseBox:
    # delta += math.padded_stack()
    if delta.shape.spatial_rank == 0:
        return GridCell(self.resolution, self.bounds.shifted(delta))
    else:
        center = self.center + delta
        return Cuboid(center, self.half_size)</code></pre>
</details>
</dd>
<dt id="phi.geom.GridCell.stagger"><code class="name flex">
<span>def <span class="ident">stagger</span></span>(<span>self, dim: str, lower: bool, upper: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stagger(self, dim: str, lower: bool, upper: bool):
    dim_mask = np.array(self.resolution.mask(dim))
    unit = self.bounds.size / self.resolution * dim_mask
    bounds = Box(self.bounds.lower + unit * (-0.5 if lower else 0.5), self.bounds.upper + unit * (0.5 if upper else -0.5))
    ext_res = self.resolution.sizes + dim_mask * (int(lower) + int(upper) - 1)
    return GridCell(self.resolution.with_sizes(ext_res), bounds)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.geom.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>location: phi.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Points have zero volume and are determined by a single location.
An instance of <code><a title="phi.geom.Point" href="#phi.geom.Point">Point</a></code> represents a single n-dimensional point or a batch of points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(Geometry):
    &#34;&#34;&#34;
    Points have zero volume and are determined by a single location.
    An instance of `Point` represents a single n-dimensional point or a batch of points.
    &#34;&#34;&#34;

    def __init__(self, location: math.Tensor):
        assert &#39;vector&#39; in location.shape, &#34;location must have a vector dimension&#34;
        assert location.shape.get_item_names(&#39;vector&#39;) is not None, &#34;Vector dimension needs to list spatial dimension as item names.&#34;
        self._location = location

    @property
    def center(self) -&gt; Tensor:
        return self._location

    @property
    def shape(self) -&gt; Shape:
        return self._location.shape

    def unstack(self, dimension: str) -&gt; tuple:
        return tuple(Point(loc) for loc in self._location.unstack(dimension))

    def lies_inside(self, location: Tensor) -&gt; Tensor:
        return expand(math.wrap(False), shape(location).without(&#39;vector&#39;))

    def approximate_signed_distance(self, location: Tensor or tuple) -&gt; Tensor:
        return math.vec_abs(location - self._location)

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        return positions

    def bounding_radius(self) -&gt; Tensor:
        return math.zeros()

    def bounding_half_extent(self) -&gt; Tensor:
        return math.zeros()

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return Point(center)

    def rotated(self, angle) -&gt; &#39;Geometry&#39;:
        return self

    def __hash__(self):
        return hash(self._location)

    def __variable_attrs__(self):
        return &#39;_location&#39;,

    @property
    def volume(self) -&gt; Tensor:
        return math.wrap(0)

    @property
    def shape_type(self) -&gt; Tensor:
        return math.tensor(&#39;P&#39;)

    def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
        raise NotImplementedError

    def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
        return self

    def __getitem__(self, item):
        return Point(self._location[_keep_vector(slicing_dict(self, item))])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Point.center"><code class="name">var <span class="ident">center</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; Tensor:
    return self._location</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.shape"><code class="name">var <span class="ident">shape</span> : phi.math._shape.Shape</code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Shape:
    return self._location.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.shape_type"><code class="name">var <span class="ident">shape_type</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the type (or types) of this geometry as a string <code>Tensor</code>
Boxes return <code>'B'</code>, spheres return <code>'S'</code>, points return <code>'P'</code>.
Returns <code>'?'</code> for unknown types, e.g. a union over multiple types.
Custom types can return their own identifiers.</p>
<h2 id="returns">Returns</h2>
<p>String <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_type(self) -&gt; Tensor:
    return math.tensor(&#39;P&#39;)</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.volume"><code class="name">var <span class="ident">volume</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Volume of the geometry as <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code>.
The result retains all batch dimensions while instance dimensions are summed over.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; Tensor:
    return math.wrap(0)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Point.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phi.math._tensors.Tensor) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the approximate distance from location to the surface of the geometry.
Locations outside return positive values, inside negative values and zero exactly at the boundary.</p>
<p>The exact distance metric used depends on the geometry.
The approximation holds close to the surface and the distance grows to infinity as the location is moved infinitely far from the geometry.
The distance metric is differentiable and its gradients are bounded at every point in space.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), the shortest distance to any instance is returned.
This also holds for negative distances.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
<dt><strong><code>location</code></strong></dt>
<dd>Tensor:</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor or tuple) -&gt; Tensor:
    return math.vec_abs(location - self._location)</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phi.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    return Point(center)</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>:return: float vector</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self) -&gt; Tensor:
    return math.zeros()</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self) -&gt; Tensor:
    return math.zeros()</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location: phi.math._tensors.Tensor) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location: Tensor) -&gt; Tensor:
    return expand(math.wrap(False), shape(location).without(&#39;vector&#39;))</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, positions: phi.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and box boundaries after shifting</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
    return positions</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>scalar (2d) or vector (3D+) representing delta angle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle) -&gt; &#39;Geometry&#39;:
    return self</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phi.math._shape.Shape) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape) -&gt; Tensor:
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
    return self</code></pre>
</details>
</dd>
<dt id="phi.geom.Point.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, dimension: str) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Unstacks this Geometry along the given dimension.
The shapes of the returned geometries are reduced by <code>dimension</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dimension</code></strong></dt>
<dd>dimension along which to unstack</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>geometries</code></dt>
<dd>tuple of length equal to <code>geometry.shape.get_size(dimension)</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unstack(self, dimension: str) -&gt; tuple:
    return tuple(Point(loc) for loc in self._location.unstack(dimension))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="phi.geom.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>center: phi.math._tensors.Tensor = None, radius: float = None, **center_: float)</span>
</code></dt>
<dd>
<div class="desc"><p>N-dimensional sphere.
Defined through center position and radius.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>Sphere center as <code>Tensor</code> with <code>vector</code> dimension.
The spatial dimension order should be specified in the <code>vector</code> dimension via item names.</dd>
<dt><strong><code>radius</code></strong></dt>
<dd>Sphere radius as <code>float</code> or <code>Tensor</code></dd>
<dt><strong><code>**center_</code></strong></dt>
<dd>Specifies center when the <code>center</code> argument is not given. Center position by dimension, e.g. <code>x=0.5, y=0.2</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sphere(Geometry):
    &#34;&#34;&#34;
    N-dimensional sphere.
    Defined through center position and radius.
    &#34;&#34;&#34;

    def __init__(self,
                 center: Tensor = None,
                 radius: float or Tensor = None,
                 **center_: float or Tensor):
        &#34;&#34;&#34;
        Args:
            center: Sphere center as `Tensor` with `vector` dimension.
                The spatial dimension order should be specified in the `vector` dimension via item names.
            radius: Sphere radius as `float` or `Tensor`
            **center_: Specifies center when the `center` argument is not given. Center position by dimension, e.g. `x=0.5, y=0.2`.
        &#34;&#34;&#34;
        if center is not None:
            assert isinstance(center, Tensor), &#34;center must be a Tensor&#34;
            assert &#39;vector&#39; in center.shape, f&#34;Sphere center must have a &#39;vector&#39; dimension.&#34;
            assert center.shape.get_item_names(&#39;vector&#39;) is not None, f&#34;Vector dimension must list spatial dimensions as item names. Use the syntax Sphere(x=x, y=y) to assign names.&#34;
            self._center = center
        else:
            self._center = wrap(tuple(center_.values()), math.channel(vector=tuple(center_.keys())))
        assert radius is not None, &#34;radius must be specified.&#34;
        self._radius = wrap(radius)
        assert &#39;vector&#39; not in self._radius.shape, f&#34;Sphere radius must not vary along vector but got {radius}&#34;

    @property
    def shape(self):
        if self._center is None or self._radius is None:
            return None
        return self._center.shape &amp; self._radius.shape

    @property
    def radius(self):
        return self._radius

    @property
    def center(self):
        return self._center

    @property
    def volume(self) -&gt; math.Tensor:
        if self.spatial_rank == 1:
            return 2 * self._radius
        elif self.spatial_rank == 2:
            return math.PI * self._radius ** 2
        elif self.spatial_rank == 3:
            return 4 / 3 * math.PI * self._radius ** 3
        else:
            raise NotImplementedError()
            # n = self.spatial_rank
            # return math.pi ** (n // 2) / math.faculty(math.ceil(n / 2)) * self._radius ** n

    @property
    def shape_type(self) -&gt; Tensor:
        return math.tensor(&#39;S&#39;)

    def lies_inside(self, location):
        distance_squared = math.sum((location - self.center) ** 2, dim=&#39;vector&#39;)
        return math.any(distance_squared &lt;= self.radius ** 2, self.shape.instance)  # union for instance dimensions

    def approximate_signed_distance(self, location: Tensor or tuple):
        &#34;&#34;&#34;
        Computes the exact distance from location to the closest point on the sphere.
        Very close to the sphere center, the distance takes a constant value.

        Args:
          location: float tensor of shape (batch_size, ..., rank)

        Returns:
          float tensor of shape (*location.shape[:-1], 1).

        &#34;&#34;&#34;
        distance_squared = math.vec_squared(location - self.center)
        distance_squared = math.maximum(distance_squared, self.radius * 1e-2)  # Prevent infinite spatial_gradient at sphere center
        distance = math.sqrt(distance_squared)
        return math.min(distance - self.radius, self.shape.instance)  # union for instance dimensions

    def sample_uniform(self, *shape: math.Shape):
        raise NotImplementedError(&#39;Not yet implemented&#39;)  # ToDo

    def bounding_radius(self):
        return self.radius

    def bounding_half_extent(self):
        return expand(self.radius, self._center.shape.only(&#39;vector&#39;))

    def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
        return Sphere(center, self._radius)

    def rotated(self, angle):
        return self

    def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
        return Sphere(self.center, self.radius * factor)

    def __variable_attrs__(self):
        return &#39;_center&#39;, &#39;_radius&#39;

    def __getitem__(self, item):
        item = slicing_dict(self, item)
        return Sphere(self._center[_keep_vector(item)], self._radius[item])

    def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
        raise NotImplementedError()

    def __hash__(self):
        return hash(self._center) + hash(self._radius)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>phi.geom._geom.Geometry</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phi.geom.Sphere.center"><code class="name">var <span class="ident">center</span></code></dt>
<dd>
<div class="desc"><p>Center location in single channel dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self._center</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radius(self):
    return self._radius</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.shape"><code class="name">var <span class="ident">shape</span></code></dt>
<dd>
<div class="desc"><p>The <code>shape</code> of a <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> consists of the following dimensions:</p>
<ul>
<li>A single <em>channel</em> dimension called <code>'vector'</code> specifying the physical space</li>
<li>Instance dimensions denote that this geometry consists of multiple copies in the same space</li>
<li>Spatial dimensions denote a crystal (repeating structure) of this geometric primitive in space</li>
<li>Batch dimensions indicate non-interacting versions of this geometry for parallelization only.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self):
    if self._center is None or self._radius is None:
        return None
    return self._center.shape &amp; self._radius.shape</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.shape_type"><code class="name">var <span class="ident">shape_type</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Returns the type (or types) of this geometry as a string <code>Tensor</code>
Boxes return <code>'B'</code>, spheres return <code>'S'</code>, points return <code>'P'</code>.
Returns <code>'?'</code> for unknown types, e.g. a union over multiple types.
Custom types can return their own identifiers.</p>
<h2 id="returns">Returns</h2>
<p>String <code>Tensor</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape_type(self) -&gt; Tensor:
    return math.tensor(&#39;S&#39;)</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.volume"><code class="name">var <span class="ident">volume</span> : phi.math._tensors.Tensor</code></dt>
<dd>
<div class="desc"><p>Volume of the geometry as <code><a title="phi.math.Tensor" href="../math/index.html#phi.math.Tensor">Tensor</a></code>.
The result retains all batch dimensions while instance dimensions are summed over.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volume(self) -&gt; math.Tensor:
    if self.spatial_rank == 1:
        return 2 * self._radius
    elif self.spatial_rank == 2:
        return math.PI * self._radius ** 2
    elif self.spatial_rank == 3:
        return 4 / 3 * math.PI * self._radius ** 3
    else:
        raise NotImplementedError()
        # n = self.spatial_rank
        # return math.pi ** (n // 2) / math.faculty(math.ceil(n / 2)) * self._radius ** n</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.geom.Sphere.approximate_signed_distance"><code class="name flex">
<span>def <span class="ident">approximate_signed_distance</span></span>(<span>self, location: phi.math._tensors.Tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the exact distance from location to the closest point on the sphere.
Very close to the sphere center, the distance takes a constant value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_signed_distance(self, location: Tensor or tuple):
    &#34;&#34;&#34;
    Computes the exact distance from location to the closest point on the sphere.
    Very close to the sphere center, the distance takes a constant value.

    Args:
      location: float tensor of shape (batch_size, ..., rank)

    Returns:
      float tensor of shape (*location.shape[:-1], 1).

    &#34;&#34;&#34;
    distance_squared = math.vec_squared(location - self.center)
    distance_squared = math.maximum(distance_squared, self.radius * 1e-2)  # Prevent infinite spatial_gradient at sphere center
    distance = math.sqrt(distance_squared)
    return math.min(distance - self.radius, self.shape.instance)  # union for instance dimensions</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, center: phi.math._tensors.Tensor) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code> with the center at <code>center</code>.
This is equal to calling <code>self @ center</code>.</p>
<p>See Also:
<code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">Geometry.shifted()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>center</code></strong></dt>
<dd>New center as <code>Tensor</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, center: Tensor) -&gt; &#39;Geometry&#39;:
    return Sphere(center, self._radius)</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.bounding_half_extent"><code class="name flex">
<span>def <span class="ident">bounding_half_extent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding half-extent sets a limit on the outer-most point for each coordinate axis.
Each component is non-negative.</p>
<p>Let the bounding half-extent have value <code>e</code> in dimension <code>d</code> (<code>extent[...,d] = e</code>).
Then, no point of the geometry lies further away from its center point than <code>e</code> along <code>d</code> (in both axis directions).</p>
<p>:return: float vector</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_half_extent(self):
    return expand(self.radius, self._center.shape.only(&#39;vector&#39;))</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.bounding_radius"><code class="name flex">
<span>def <span class="ident">bounding_radius</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radius of a Sphere object that fully encloses this geometry.
The sphere is centered at the center of this geometry.</p>
<p>:return: radius of type float</p>
<p>Args:</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bounding_radius(self):
    return self.radius</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.lies_inside"><code class="name flex">
<span>def <span class="ident">lies_inside</span></span>(<span>self, location)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether the given location lies inside or outside of the geometry. Locations on the surface count as inside.</p>
<p>When dealing with unions or collections of geometries (instance dimensions), a point lies inside the geometry if it lies inside any instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>location</code></strong></dt>
<dd>float tensor of shape (batch_size, &hellip;, rank)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>bool tensor of shape (*location.shape[:-1], 1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lies_inside(self, location):
    distance_squared = math.sum((location - self.center) ** 2, dim=&#39;vector&#39;)
    return math.any(distance_squared &lt;= self.radius ** 2, self.shape.instance)  # union for instance dimensions</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.push"><code class="name flex">
<span>def <span class="ident">push</span></span>(<span>self, positions: phi.math._tensors.Tensor, outward: bool = True, shift_amount: float = 0) ‑> phi.math._tensors.Tensor</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts positions either into or out of geometry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>positions</code></strong></dt>
<dd>Tensor holding positions to shift</dd>
<dt><strong><code>outward</code></strong></dt>
<dd>Flag for indicating inward (False) or outward (True) shift</dd>
<dt><strong><code>shift_amount</code></strong></dt>
<dd>Minimum distance between positions and box boundaries after shifting</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tensor holding shifted positions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push(self, positions: Tensor, outward: bool = True, shift_amount: float = 0) -&gt; Tensor:
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.rotated"><code class="name flex">
<span>def <span class="ident">rotated</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a rotated version of this geometry.
The geometry is rotated about its center point.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>scalar (2d) or vector (3D+) representing delta angle</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Rotated <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotated(self, angle):
    return self</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.sample_uniform"><code class="name flex">
<span>def <span class="ident">sample_uniform</span></span>(<span>self, *shape: phi.math._shape.Shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Samples uniformly distributed random points inside this volume.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*shape</code></strong></dt>
<dd>How many points to sample per individual geometry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>Tensor</code> containing all dimensions from <code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">Geometry.shape</a></code>, <code>shape</code> as well as a <code>channel</code> dimension <code>vector</code> matching the dimensionality of this <code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_uniform(self, *shape: math.Shape):
    raise NotImplementedError(&#39;Not yet implemented&#39;)  # ToDo</code></pre>
</details>
</dd>
<dt id="phi.geom.Sphere.scaled"><code class="name flex">
<span>def <span class="ident">scaled</span></span>(<span>self, factor: float) ‑> phi.geom._geom.Geometry</span>
</code></dt>
<dd>
<div class="desc"><p>Scales each individual geometry by <code>factor</code>.
The individual <code>center</code> points act as pivots for the operation.</p>
<h2 id="args">Args</h2>
<p>factor:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scaled(self, factor: float or Tensor) -&gt; &#39;Geometry&#39;:
    return Sphere(self.center, self.radius * factor)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi" href="../index.html">phi</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="phi.geom.assert_same_rank" href="#phi.geom.assert_same_rank">assert_same_rank</a></code></li>
<li><code><a title="phi.geom.concat" href="#phi.geom.concat">concat</a></code></li>
<li><code><a title="phi.geom.embed" href="#phi.geom.embed">embed</a></code></li>
<li><code><a title="phi.geom.infinite_cylinder" href="#phi.geom.infinite_cylinder">infinite_cylinder</a></code></li>
<li><code><a title="phi.geom.invert" href="#phi.geom.invert">invert</a></code></li>
<li><code><a title="phi.geom.pack_dims" href="#phi.geom.pack_dims">pack_dims</a></code></li>
<li><code><a title="phi.geom.stack" href="#phi.geom.stack">stack</a></code></li>
<li><code><a title="phi.geom.union" href="#phi.geom.union">union</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.geom.BaseBox" href="#phi.geom.BaseBox">BaseBox</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.BaseBox.approximate_signed_distance" href="#phi.geom.BaseBox.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.BaseBox.at" href="#phi.geom.BaseBox.at">at</a></code></li>
<li><code><a title="phi.geom.BaseBox.bounding_half_extent" href="#phi.geom.BaseBox.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.BaseBox.bounding_radius" href="#phi.geom.BaseBox.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.BaseBox.box" href="#phi.geom.BaseBox.box">box</a></code></li>
<li><code><a title="phi.geom.BaseBox.center" href="#phi.geom.BaseBox.center">center</a></code></li>
<li><code><a title="phi.geom.BaseBox.center_representation" href="#phi.geom.BaseBox.center_representation">center_representation</a></code></li>
<li><code><a title="phi.geom.BaseBox.contains" href="#phi.geom.BaseBox.contains">contains</a></code></li>
<li><code><a title="phi.geom.BaseBox.corner_representation" href="#phi.geom.BaseBox.corner_representation">corner_representation</a></code></li>
<li><code><a title="phi.geom.BaseBox.global_to_local" href="#phi.geom.BaseBox.global_to_local">global_to_local</a></code></li>
<li><code><a title="phi.geom.BaseBox.half_size" href="#phi.geom.BaseBox.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.BaseBox.lies_inside" href="#phi.geom.BaseBox.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.BaseBox.local_to_global" href="#phi.geom.BaseBox.local_to_global">local_to_global</a></code></li>
<li><code><a title="phi.geom.BaseBox.lower" href="#phi.geom.BaseBox.lower">lower</a></code></li>
<li><code><a title="phi.geom.BaseBox.project" href="#phi.geom.BaseBox.project">project</a></code></li>
<li><code><a title="phi.geom.BaseBox.push" href="#phi.geom.BaseBox.push">push</a></code></li>
<li><code><a title="phi.geom.BaseBox.rotated" href="#phi.geom.BaseBox.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.BaseBox.sample_uniform" href="#phi.geom.BaseBox.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.BaseBox.scaled" href="#phi.geom.BaseBox.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.BaseBox.shape" href="#phi.geom.BaseBox.shape">shape</a></code></li>
<li><code><a title="phi.geom.BaseBox.shape_type" href="#phi.geom.BaseBox.shape_type">shape_type</a></code></li>
<li><code><a title="phi.geom.BaseBox.size" href="#phi.geom.BaseBox.size">size</a></code></li>
<li><code><a title="phi.geom.BaseBox.upper" href="#phi.geom.BaseBox.upper">upper</a></code></li>
<li><code><a title="phi.geom.BaseBox.volume" href="#phi.geom.BaseBox.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Box" href="#phi.geom.Box">Box</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.geom.Box.center" href="#phi.geom.Box.center">center</a></code></li>
<li><code><a title="phi.geom.Box.half_size" href="#phi.geom.Box.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.Box.lower" href="#phi.geom.Box.lower">lower</a></code></li>
<li><code><a title="phi.geom.Box.shape" href="#phi.geom.Box.shape">shape</a></code></li>
<li><code><a title="phi.geom.Box.shifted" href="#phi.geom.Box.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Box.size" href="#phi.geom.Box.size">size</a></code></li>
<li><code><a title="phi.geom.Box.upper" href="#phi.geom.Box.upper">upper</a></code></li>
<li><code><a title="phi.geom.Box.without" href="#phi.geom.Box.without">without</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Cuboid" href="#phi.geom.Cuboid">Cuboid</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.geom.Cuboid.center" href="#phi.geom.Cuboid.center">center</a></code></li>
<li><code><a title="phi.geom.Cuboid.half_size" href="#phi.geom.Cuboid.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.Cuboid.lower" href="#phi.geom.Cuboid.lower">lower</a></code></li>
<li><code><a title="phi.geom.Cuboid.shape" href="#phi.geom.Cuboid.shape">shape</a></code></li>
<li><code><a title="phi.geom.Cuboid.shifted" href="#phi.geom.Cuboid.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Cuboid.size" href="#phi.geom.Cuboid.size">size</a></code></li>
<li><code><a title="phi.geom.Cuboid.upper" href="#phi.geom.Cuboid.upper">upper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Geometry" href="#phi.geom.Geometry">Geometry</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Geometry.approximate_fraction_inside" href="#phi.geom.Geometry.approximate_fraction_inside">approximate_fraction_inside</a></code></li>
<li><code><a title="phi.geom.Geometry.approximate_signed_distance" href="#phi.geom.Geometry.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Geometry.at" href="#phi.geom.Geometry.at">at</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_box" href="#phi.geom.Geometry.bounding_box">bounding_box</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_half_extent" href="#phi.geom.Geometry.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Geometry.bounding_radius" href="#phi.geom.Geometry.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Geometry.center" href="#phi.geom.Geometry.center">center</a></code></li>
<li><code><a title="phi.geom.Geometry.lies_inside" href="#phi.geom.Geometry.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Geometry.push" href="#phi.geom.Geometry.push">push</a></code></li>
<li><code><a title="phi.geom.Geometry.rotated" href="#phi.geom.Geometry.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Geometry.sample_uniform" href="#phi.geom.Geometry.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Geometry.scaled" href="#phi.geom.Geometry.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Geometry.shallow_equals" href="#phi.geom.Geometry.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.Geometry.shape" href="#phi.geom.Geometry.shape">shape</a></code></li>
<li><code><a title="phi.geom.Geometry.shape_type" href="#phi.geom.Geometry.shape_type">shape_type</a></code></li>
<li><code><a title="phi.geom.Geometry.shifted" href="#phi.geom.Geometry.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.Geometry.spatial_rank" href="#phi.geom.Geometry.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.geom.Geometry.unstack" href="#phi.geom.Geometry.unstack">unstack</a></code></li>
<li><code><a title="phi.geom.Geometry.volume" href="#phi.geom.Geometry.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.GridCell" href="#phi.geom.GridCell">GridCell</a></code></h4>
<ul class="two-column">
<li><code><a title="phi.geom.GridCell.bounds" href="#phi.geom.GridCell.bounds">bounds</a></code></li>
<li><code><a title="phi.geom.GridCell.center" href="#phi.geom.GridCell.center">center</a></code></li>
<li><code><a title="phi.geom.GridCell.dx" href="#phi.geom.GridCell.dx">dx</a></code></li>
<li><code><a title="phi.geom.GridCell.grid_size" href="#phi.geom.GridCell.grid_size">grid_size</a></code></li>
<li><code><a title="phi.geom.GridCell.half_size" href="#phi.geom.GridCell.half_size">half_size</a></code></li>
<li><code><a title="phi.geom.GridCell.list_cells" href="#phi.geom.GridCell.list_cells">list_cells</a></code></li>
<li><code><a title="phi.geom.GridCell.lower" href="#phi.geom.GridCell.lower">lower</a></code></li>
<li><code><a title="phi.geom.GridCell.padded" href="#phi.geom.GridCell.padded">padded</a></code></li>
<li><code><a title="phi.geom.GridCell.resolution" href="#phi.geom.GridCell.resolution">resolution</a></code></li>
<li><code><a title="phi.geom.GridCell.rotated" href="#phi.geom.GridCell.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.GridCell.shallow_equals" href="#phi.geom.GridCell.shallow_equals">shallow_equals</a></code></li>
<li><code><a title="phi.geom.GridCell.shape" href="#phi.geom.GridCell.shape">shape</a></code></li>
<li><code><a title="phi.geom.GridCell.shifted" href="#phi.geom.GridCell.shifted">shifted</a></code></li>
<li><code><a title="phi.geom.GridCell.size" href="#phi.geom.GridCell.size">size</a></code></li>
<li><code><a title="phi.geom.GridCell.spatial_rank" href="#phi.geom.GridCell.spatial_rank">spatial_rank</a></code></li>
<li><code><a title="phi.geom.GridCell.stagger" href="#phi.geom.GridCell.stagger">stagger</a></code></li>
<li><code><a title="phi.geom.GridCell.upper" href="#phi.geom.GridCell.upper">upper</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Point" href="#phi.geom.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Point.approximate_signed_distance" href="#phi.geom.Point.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Point.at" href="#phi.geom.Point.at">at</a></code></li>
<li><code><a title="phi.geom.Point.bounding_half_extent" href="#phi.geom.Point.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Point.bounding_radius" href="#phi.geom.Point.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Point.center" href="#phi.geom.Point.center">center</a></code></li>
<li><code><a title="phi.geom.Point.lies_inside" href="#phi.geom.Point.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Point.push" href="#phi.geom.Point.push">push</a></code></li>
<li><code><a title="phi.geom.Point.rotated" href="#phi.geom.Point.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Point.sample_uniform" href="#phi.geom.Point.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Point.scaled" href="#phi.geom.Point.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Point.shape" href="#phi.geom.Point.shape">shape</a></code></li>
<li><code><a title="phi.geom.Point.shape_type" href="#phi.geom.Point.shape_type">shape_type</a></code></li>
<li><code><a title="phi.geom.Point.unstack" href="#phi.geom.Point.unstack">unstack</a></code></li>
<li><code><a title="phi.geom.Point.volume" href="#phi.geom.Point.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phi.geom.Sphere" href="#phi.geom.Sphere">Sphere</a></code></h4>
<ul class="">
<li><code><a title="phi.geom.Sphere.approximate_signed_distance" href="#phi.geom.Sphere.approximate_signed_distance">approximate_signed_distance</a></code></li>
<li><code><a title="phi.geom.Sphere.at" href="#phi.geom.Sphere.at">at</a></code></li>
<li><code><a title="phi.geom.Sphere.bounding_half_extent" href="#phi.geom.Sphere.bounding_half_extent">bounding_half_extent</a></code></li>
<li><code><a title="phi.geom.Sphere.bounding_radius" href="#phi.geom.Sphere.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="phi.geom.Sphere.center" href="#phi.geom.Sphere.center">center</a></code></li>
<li><code><a title="phi.geom.Sphere.lies_inside" href="#phi.geom.Sphere.lies_inside">lies_inside</a></code></li>
<li><code><a title="phi.geom.Sphere.push" href="#phi.geom.Sphere.push">push</a></code></li>
<li><code><a title="phi.geom.Sphere.radius" href="#phi.geom.Sphere.radius">radius</a></code></li>
<li><code><a title="phi.geom.Sphere.rotated" href="#phi.geom.Sphere.rotated">rotated</a></code></li>
<li><code><a title="phi.geom.Sphere.sample_uniform" href="#phi.geom.Sphere.sample_uniform">sample_uniform</a></code></li>
<li><code><a title="phi.geom.Sphere.scaled" href="#phi.geom.Sphere.scaled">scaled</a></code></li>
<li><code><a title="phi.geom.Sphere.shape" href="#phi.geom.Sphere.shape">shape</a></code></li>
<li><code><a title="phi.geom.Sphere.shape_type" href="#phi.geom.Sphere.shape_type">shape_type</a></code></li>
<li><code><a title="phi.geom.Sphere.volume" href="#phi.geom.Sphere.volume">volume</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>