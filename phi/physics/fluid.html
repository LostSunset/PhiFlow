<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>phi.physics.fluid API documentation</title>
<meta name="description" content="Functions for simulating incompressible fluids, both grid-based and particle-based â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phi.physics.fluid</code></h1>
</header>
<section id="section-intro">
<p>Functions for simulating incompressible fluids, both grid-based and particle-based.</p>
<p>The main function for incompressible fluids (Eulerian as well as FLIP / PIC) is <code><a title="phi.physics.fluid.make_incompressible" href="#phi.physics.fluid.make_incompressible">make_incompressible()</a></code> which removes the divergence of a velocity field.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions for simulating incompressible fluids, both grid-based and particle-based.

The main function for incompressible fluids (Eulerian as well as FLIP / PIC) is `make_incompressible()` which removes the divergence of a velocity field.
&#34;&#34;&#34;
import warnings
from typing import Tuple, Callable, Union

from phi import math, field
from phiml.math import wrap, channel, Solve
from phi.field import AngularVelocity, Grid, divergence, spatial_gradient, where, CenteredGrid, PointCloud, Field, resample
from phi.geom import union, Geometry
from ..field._embed import FieldEmbedding
from ..field._grid import GridType, StaggeredGrid
from phiml.math import extrapolation, NUMPY, batch, shape, non_channel, expand
from phiml.math._magic_ops import copy_with
from phiml.math.extrapolation import combine_sides, Extrapolation


class Obstacle:
    &#34;&#34;&#34;
    An obstacle defines boundary conditions inside a geometry.
    It can also have a linear and angular velocity.
    &#34;&#34;&#34;

    def __init__(self, geometry, velocity=0, angular_velocity=0):
        &#34;&#34;&#34;
        Args:
            geometry: Physical shape and size of the obstacle.
            velocity: Linear velocity vector of the obstacle.
            angular_velocity: Rotation speed of the obstacle. Scalar value in 2D, vector in 3D.
        &#34;&#34;&#34;
        self.geometry = geometry
        self.velocity = wrap(velocity, channel(geometry)) if isinstance(velocity, (tuple, list)) else velocity
        self.angular_velocity = angular_velocity
        self.shape = shape(geometry) &amp; non_channel(self.velocity) &amp; non_channel(angular_velocity)

    @property
    def is_stationary(self):
        &#34;&#34;&#34; Test whether the obstacle is completely still. &#34;&#34;&#34;
        return not self.is_moving and not self.is_rotating

    @property
    def is_rotating(self):
        available = self.angular_velocity.available if isinstance(self.angular_velocity, math.Tensor) else True
        return not available or math.any(self.angular_velocity != 0).any

    @property
    def is_moving(self):
        available = self.velocity.available if isinstance(self.velocity, math.Tensor) else True
        return not available or math.any(self.velocity != 0).any

    def copied_with(self, **kwargs):
        warnings.warn(&#34;Obstacle.copied_with is deprecated. Use math.copy_with instead.&#34;, DeprecationWarning, stacklevel=2)
        return math.copy_with(self, **kwargs)

    def __variable_attrs__(self) -&gt; Tuple[str, ...]:
        return &#39;geometry&#39;, &#39;velocity&#39;, &#39;angular_velocity&#39;

    def __eq__(self, other):
        if not isinstance(other, Obstacle):
            return False
        return self.geometry == other.geometry and self.velocity == other.velocity and self.angular_velocity == other.angular_velocity


def _get_obstacles_for(obstacles, space: Field):
    obstacles = [obstacles] if isinstance(obstacles, (Obstacle, Geometry)) else obstacles
    assert isinstance(obstacles, (tuple, list)), f&#34;obstacles must be an Obstacle or Geometry or a tuple/list thereof but got {type(obstacles)}&#34;
    obstacles = [Obstacle(o) if isinstance(o, Geometry) else o for o in obstacles]
    for obstacle in obstacles:
        assert obstacle.geometry.vector.item_names == space.vector.item_names, f&#34;Obstacles must live in the same physical space as the velocity field {space.vector.item_names} but got {type(obstacle.geometry).__name__} obstacle with order {obstacle.geometry.vector.item_names}&#34;
    return obstacles


def make_incompressible(velocity: GridType,
                        obstacles: Union[Obstacle, Geometry, tuple, list] = (),
                        solve: Solve = Solve(),
                        active: CenteredGrid = None,
                        order: int = 2) -&gt; Tuple[GridType, CenteredGrid]:
    &#34;&#34;&#34;
    Projects the given velocity field by solving for the pressure and subtracting its spatial_gradient.
    
    This method is similar to :func:`field.divergence_free()` but differs in how the boundary conditions are specified.

    Args:
        velocity: Vector field sampled on a grid.
        obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.
        solve: `Solve` object specifying method and tolerances for the implicit pressure solve.
        active: (Optional) Mask for which cells the pressure should be solved.
            If given, the velocity may take `NaN` values where it does not contribute to the pressure.
            Also, the total divergence will never be subtracted if active is given, even if all values are 1.
        order: spatial order for derivative computations.
            For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.
            While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.
            supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)

    Returns:
        velocity: divergence-free velocity of type `type(velocity)`
        pressure: solved pressure field, `CenteredGrid`
    &#34;&#34;&#34;
    obstacles = _get_obstacles_for(obstacles, velocity)
    assert order == 2 or len(obstacles) == 0, f&#34;obstacles are not supported with higher order schemes&#34;
    input_velocity = velocity
    # --- Create masks ---
    accessible_extrapolation = _accessible_extrapolation(input_velocity.extrapolation)
    with NUMPY:
        accessible = CenteredGrid(~union([obs.geometry for obs in obstacles]), accessible_extrapolation, velocity.bounds, velocity.resolution)
        hard_bcs = field.stagger(accessible, math.minimum, input_velocity.extrapolation, type=type(velocity))
    all_active = active is None
    if active is None:
        active = accessible.with_extrapolation(extrapolation.NONE)
    else:
        active *= accessible  # no pressure inside obstacles
    # --- Linear solve ---
    velocity = apply_boundary_conditions(velocity, obstacles)
    div = divergence(velocity, order=order) * active
    if not all_active:  # NaN in velocity allowed
        div = field.where(field.is_finite(div), div, 0)
    if not input_velocity.extrapolation.is_flexible and all_active:
        solve = solve.with_preprocessing(_balance_divergence, active)
    if solve.x0 is None:
        pressure_extrapolation = _pressure_extrapolation(input_velocity.extrapolation)
        solve = copy_with(solve, x0=CenteredGrid(0, pressure_extrapolation, div.bounds, div.resolution))
    if batch(math.merge_shapes(*obstacles)).without(batch(solve.x0)):  # The initial pressure guess must contain all batch dimensions
        solve = copy_with(solve, x0=expand(solve.x0, batch(math.merge_shapes(*obstacles))))
    pressure = math.solve_linear(masked_laplace, div, solve, hard_bcs, active, order=order)
    # --- Subtract grad p ---
    grad_pressure = field.spatial_gradient(pressure, input_velocity.extrapolation, type=type(velocity), order=order) * hard_bcs
    velocity = (velocity - grad_pressure).with_extrapolation(input_velocity.extrapolation)
    return velocity, pressure


@math.jit_compile_linear(auxiliary_args=&#39;hard_bcs,active,order,implicit&#39;, forget_traces=True)  # jit compilation is required for boundary conditions that add a constant offset solving Ax + b = y
def masked_laplace(pressure: CenteredGrid, hard_bcs: Grid, active: CenteredGrid, order=2, implicit: Solve = None) -&gt; CenteredGrid:
    &#34;&#34;&#34;
    Computes the laplace of `pressure` in the presence of obstacles.

    Args:
        pressure: Pressure field.
        hard_bcs: Mask encoding which cells are connected to each other.
            One between fluid cells, zero inside and at the boundary of obstacles.
            This should be of the same type as the velocity, i.e. `StaggeredGrid` or `CenteredGrid`.
        active: Mask indicating for which cells the pressure value is valid.
            Linear solves will only determine the pressure for these cells.
            This is generally zero inside obstacles and in non-simulated regions.
        order: Spatial order of accuracy.
            Higher orders entail larger stencils and more computation time but result in more accurate results assuming a large enough resolution.
            Supported: 2 explicit, 4 explicit, 6 implicit (inherited from `phi.field.laplace()`).
        implicit: When a `Solve` object is passed, performs an implicit operation with the specified solver and tolerances.
            Otherwise, an explicit stencil is used.

    Returns:
        `CenteredGrid`
    &#34;&#34;&#34;
    if order == 2 and not implicit:
        grad = spatial_gradient(pressure, hard_bcs.extrapolation, type=type(hard_bcs))
        valid_grad = grad * hard_bcs
        valid_grad = valid_grad.with_extrapolation(extrapolation.remove_constant_offset(valid_grad.extrapolation))
        div = divergence(valid_grad)
        laplace = where(active, div, pressure)
    else:
        laplace = field.laplace(pressure, order=order, implicit=implicit)
    return laplace


def _balance_divergence(div, active):
    return div - active * (field.mean(div) / field.mean(active))


def apply_boundary_conditions(velocity: Union[Grid, PointCloud], obstacles: Union[Obstacle, Geometry, tuple, list]):
    &#34;&#34;&#34;
    Enforces velocities boundary conditions on a velocity grid.
    Cells inside obstacles will get their velocity from the obstacle movement.
    Cells outside far away will be unaffected.

    Args:
      velocity: Velocity `Grid`.
        obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.

    Returns:
        Velocity of same type as `velocity`
    &#34;&#34;&#34;
    obstacles = _get_obstacles_for(obstacles, velocity)
    # velocity = field.bake_extrapolation(velocity)  # TODO we should bake only for divergence but keep correct extrapolation for velocity. However, obstacles should override extrapolation.
    for obstacle in obstacles:
        if isinstance(obstacle, Geometry):
            obstacle = Obstacle(obstacle)
        assert isinstance(obstacle, Obstacle)
        obs_mask = resample(obstacle.geometry, velocity, soft=True, balance=1)
        if obstacle.is_stationary:
            velocity = (1 - obs_mask) * velocity
        else:
            if obstacle.is_rotating:
                angular_velocity = AngularVelocity(location=obstacle.geometry.center, strength=obstacle.angular_velocity, falloff=None) @ velocity
            else:
                angular_velocity = 0
            velocity = (1 - obs_mask) * velocity + obs_mask * (angular_velocity + obstacle.velocity)
    return velocity


def boundary_push(particles: PointCloud, obstacles: Union[tuple, list], offset: float = 0.5) -&gt; PointCloud:
    &#34;&#34;&#34;
    Enforces boundary conditions by correcting possible errors of the advection step and shifting particles out of
    obstacles or back into the domain.

    Args:
        particles: PointCloud holding particle positions as elements
        obstacles: List of `Obstacle` or `Geometry` objects where any particles inside should get shifted outwards
        offset: Minimum distance between particles and domain boundary / obstacle surface after particles have been shifted.

    Returns:
        PointCloud where all particles are inside the domain / outside of obstacles.
    &#34;&#34;&#34;
    pos = particles.elements.center
    for obj in obstacles:
        geometry = obj.geometry if isinstance(obj, Obstacle) else obj
        assert isinstance(geometry, Geometry), f&#34;obstacles must be a list of Obstacle or Geometry objects but got {type(obj)}&#34;
        pos = geometry.push(pos, shift_amount=offset)
    return particles.with_elements(particles.elements @ pos)


def _pressure_extrapolation(vext: Extrapolation):
    if vext == extrapolation.PERIODIC:
        return extrapolation.PERIODIC
    elif vext == extrapolation.BOUNDARY:
        return extrapolation.ZERO
    elif isinstance(vext, extrapolation.ConstantExtrapolation):
        return extrapolation.BOUNDARY
    else:
        return extrapolation.map(_pressure_extrapolation, vext)


def _accessible_extrapolation(vext: Extrapolation):
    &#34;&#34;&#34; Determine whether outside cells are accessible based on the velocity extrapolation. &#34;&#34;&#34;
    if vext == extrapolation.PERIODIC:
        return extrapolation.PERIODIC
    elif vext == extrapolation.BOUNDARY:
        return extrapolation.ONE
    elif isinstance(vext, extrapolation.ConstantExtrapolation):
        return extrapolation.ZERO
    elif isinstance(vext, FieldEmbedding):
        return extrapolation.ONE
    elif isinstance(vext, extrapolation._MixedExtrapolation):
        return combine_sides(**{dim: (_accessible_extrapolation(lo), _accessible_extrapolation(hi)) for dim, (lo, hi) in vext.ext.items()})
    elif isinstance(vext, extrapolation._NormalTangentialExtrapolation):
        return _accessible_extrapolation(vext.normal)
    else:
        raise ValueError(f&#34;Unsupported extrapolation: {type(vext)}&#34;)


def incompressible_rk4(pde: Callable, velocity: GridType, pressure: CenteredGrid, dt, pressure_order=4, pressure_solve=Solve(&#39;CG&#39;), **pde_aux_kwargs):
    &#34;&#34;&#34;
    Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.
    This approach is inspired by [Kampanis et. al., 2006](https://www.sciencedirect.com/science/article/pii/S0021999105005061) and incorporates the pressure treatment into the time step.

    Args:
        pde: Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.
        velocity: Velocity grid at time `t`.
        pressure: Pressure at time `t`.
        dt: Time increment to integrate.
        pressure_order: spatial order for derivative computations.
            For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.
            While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.
            supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)
        pressure_solve: `Solve` object specifying method and tolerances for the implicit pressure solve.
        **pde_aux_kwargs: Auxiliary arguments for `pde`. These are considered constant over time.

    Returns:
        velocity: Velocity at time `t+dt`, same type as `velocity`.
        pressure: Pressure grid at time `t+dt`, `CenteredGrid`.
    &#34;&#34;&#34;
    v_1, p_1 = velocity, pressure
    # PDE at current point
    rhs_1 = pde(v_1, **pde_aux_kwargs) - field.spatial_gradient(p_1, type=StaggeredGrid, order=pressure_order)
    v_2_old = velocity + (dt / 2) * rhs_1
    v_2, delta_p = make_incompressible(v_2_old, solve=pressure_solve, order=pressure_order)
    p_2 = p_1 + delta_p / dt
    # PDE at half-point
    rhs_2 = pde(v_2, **pde_aux_kwargs) - field.spatial_gradient(p_2, type=StaggeredGrid, order=pressure_order)
    v_3_old = velocity + (dt / 2) * rhs_2
    v_3, delta_p = make_incompressible(v_3_old, solve=pressure_solve, order=pressure_order)
    p_3 = p_2 + delta_p / dt
    # PDE at corrected half-point
    rhs_3 = pde(v_3, **pde_aux_kwargs) - field.spatial_gradient(p_3, type=StaggeredGrid, order=pressure_order)
    v_4_old = velocity + dt * rhs_2
    v_4, delta_p = make_incompressible(v_4_old, solve=pressure_solve, order=pressure_order)
    p_4 = p_3 + delta_p / dt
    # PDE at RK4 point
    rhs_4 = pde(v_4, **pde_aux_kwargs) - field.spatial_gradient(p_4, type=StaggeredGrid, order=pressure_order)
    v_p1_old = velocity + (dt / 6) * (rhs_1 + 2 * rhs_2 + 2 * rhs_3 + rhs_4)
    p_p1_old = (1 / 6) * (p_1 + 2 * p_2 + 2 * p_3 + p_4)
    v_p1, delta_p = make_incompressible(v_p1_old, solve=pressure_solve, order=pressure_order)
    p_p1 = p_p1_old + delta_p / dt
    return v_p1, p_p1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phi.physics.fluid.apply_boundary_conditions"><code class="name flex">
<span>def <span class="ident">apply_boundary_conditions</span></span>(<span>velocity:Â Union[phi.field._grid.Grid,Â phi.field._point_cloud.PointCloud], obstacles:Â Union[<a title="phi.physics.fluid.Obstacle" href="#phi.physics.fluid.Obstacle">Obstacle</a>,Â phi.geom._geom.Geometry,Â tuple,Â list])</span>
</code></dt>
<dd>
<div class="desc"><p>Enforces velocities boundary conditions on a velocity grid.
Cells inside obstacles will get their velocity from the obstacle movement.
Cells outside far away will be unaffected.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>velocity</code></strong></dt>
<dd>Velocity <code>Grid</code>.
obstacles: <code><a title="phi.physics.fluid.Obstacle" href="#phi.physics.fluid.Obstacle">Obstacle</a></code> or <code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code> or tuple/list thereof to specify boundary conditions inside the domain.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Velocity of same type as <code>velocity</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_boundary_conditions(velocity: Union[Grid, PointCloud], obstacles: Union[Obstacle, Geometry, tuple, list]):
    &#34;&#34;&#34;
    Enforces velocities boundary conditions on a velocity grid.
    Cells inside obstacles will get their velocity from the obstacle movement.
    Cells outside far away will be unaffected.

    Args:
      velocity: Velocity `Grid`.
        obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.

    Returns:
        Velocity of same type as `velocity`
    &#34;&#34;&#34;
    obstacles = _get_obstacles_for(obstacles, velocity)
    # velocity = field.bake_extrapolation(velocity)  # TODO we should bake only for divergence but keep correct extrapolation for velocity. However, obstacles should override extrapolation.
    for obstacle in obstacles:
        if isinstance(obstacle, Geometry):
            obstacle = Obstacle(obstacle)
        assert isinstance(obstacle, Obstacle)
        obs_mask = resample(obstacle.geometry, velocity, soft=True, balance=1)
        if obstacle.is_stationary:
            velocity = (1 - obs_mask) * velocity
        else:
            if obstacle.is_rotating:
                angular_velocity = AngularVelocity(location=obstacle.geometry.center, strength=obstacle.angular_velocity, falloff=None) @ velocity
            else:
                angular_velocity = 0
            velocity = (1 - obs_mask) * velocity + obs_mask * (angular_velocity + obstacle.velocity)
    return velocity</code></pre>
</details>
</dd>
<dt id="phi.physics.fluid.boundary_push"><code class="name flex">
<span>def <span class="ident">boundary_push</span></span>(<span>particles:Â phi.field._point_cloud.PointCloud, obstacles:Â Union[tuple,Â list], offset:Â floatÂ =Â 0.5) â€‘>Â phi.field._point_cloud.PointCloud</span>
</code></dt>
<dd>
<div class="desc"><p>Enforces boundary conditions by correcting possible errors of the advection step and shifting particles out of
obstacles or back into the domain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>particles</code></strong></dt>
<dd>PointCloud holding particle positions as elements</dd>
<dt><strong><code>obstacles</code></strong></dt>
<dd>List of <code><a title="phi.physics.fluid.Obstacle" href="#phi.physics.fluid.Obstacle">Obstacle</a></code> or <code>Geometry</code> objects where any particles inside should get shifted outwards</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>Minimum distance between particles and domain boundary / obstacle surface after particles have been shifted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>PointCloud where all particles are inside the domain / outside of obstacles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundary_push(particles: PointCloud, obstacles: Union[tuple, list], offset: float = 0.5) -&gt; PointCloud:
    &#34;&#34;&#34;
    Enforces boundary conditions by correcting possible errors of the advection step and shifting particles out of
    obstacles or back into the domain.

    Args:
        particles: PointCloud holding particle positions as elements
        obstacles: List of `Obstacle` or `Geometry` objects where any particles inside should get shifted outwards
        offset: Minimum distance between particles and domain boundary / obstacle surface after particles have been shifted.

    Returns:
        PointCloud where all particles are inside the domain / outside of obstacles.
    &#34;&#34;&#34;
    pos = particles.elements.center
    for obj in obstacles:
        geometry = obj.geometry if isinstance(obj, Obstacle) else obj
        assert isinstance(geometry, Geometry), f&#34;obstacles must be a list of Obstacle or Geometry objects but got {type(obj)}&#34;
        pos = geometry.push(pos, shift_amount=offset)
    return particles.with_elements(particles.elements @ pos)</code></pre>
</details>
</dd>
<dt id="phi.physics.fluid.incompressible_rk4"><code class="name flex">
<span>def <span class="ident">incompressible_rk4</span></span>(<span>pde:Â Callable, velocity:Â ~GridType, pressure:Â phi.field._grid.CenteredGrid, dt, pressure_order=4, pressure_solve=CG with tolerance None (rel), None (abs), max_iterations=1000, **pde_aux_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.
This approach is inspired by <a href="https://www.sciencedirect.com/science/article/pii/S0021999105005061">Kampanis et. al., 2006</a> and incorporates the pressure treatment into the time step.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pde</code></strong></dt>
<dd>Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>Velocity grid at time <code>t</code>.</dd>
<dt><strong><code>pressure</code></strong></dt>
<dd>Pressure at time <code>t</code>.</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>Time increment to integrate.</dd>
<dt><strong><code>pressure_order</code></strong></dt>
<dd>spatial order for derivative computations.
For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.
While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.
supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)</dd>
<dt><strong><code>pressure_solve</code></strong></dt>
<dd><code>Solve</code> object specifying method and tolerances for the implicit pressure solve.</dd>
<dt><strong><code>**pde_aux_kwargs</code></strong></dt>
<dd>Auxiliary arguments for <code>pde</code>. These are considered constant over time.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>velocity</code></dt>
<dd>Velocity at time <code>t+dt</code>, same type as <code>velocity</code>.</dd>
<dt><code>pressure</code></dt>
<dd>Pressure grid at time <code>t+dt</code>, <code>CenteredGrid</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incompressible_rk4(pde: Callable, velocity: GridType, pressure: CenteredGrid, dt, pressure_order=4, pressure_solve=Solve(&#39;CG&#39;), **pde_aux_kwargs):
    &#34;&#34;&#34;
    Implements the 4th-order Runge-Kutta time advancement scheme for incompressible vector fields.
    This approach is inspired by [Kampanis et. al., 2006](https://www.sciencedirect.com/science/article/pii/S0021999105005061) and incorporates the pressure treatment into the time step.

    Args:
        pde: Momentum equation. Function that computes all PDE terms not related to pressure, e.g. diffusion, advection, external forces.
        velocity: Velocity grid at time `t`.
        pressure: Pressure at time `t`.
        dt: Time increment to integrate.
        pressure_order: spatial order for derivative computations.
            For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.
            While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.
            supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)
        pressure_solve: `Solve` object specifying method and tolerances for the implicit pressure solve.
        **pde_aux_kwargs: Auxiliary arguments for `pde`. These are considered constant over time.

    Returns:
        velocity: Velocity at time `t+dt`, same type as `velocity`.
        pressure: Pressure grid at time `t+dt`, `CenteredGrid`.
    &#34;&#34;&#34;
    v_1, p_1 = velocity, pressure
    # PDE at current point
    rhs_1 = pde(v_1, **pde_aux_kwargs) - field.spatial_gradient(p_1, type=StaggeredGrid, order=pressure_order)
    v_2_old = velocity + (dt / 2) * rhs_1
    v_2, delta_p = make_incompressible(v_2_old, solve=pressure_solve, order=pressure_order)
    p_2 = p_1 + delta_p / dt
    # PDE at half-point
    rhs_2 = pde(v_2, **pde_aux_kwargs) - field.spatial_gradient(p_2, type=StaggeredGrid, order=pressure_order)
    v_3_old = velocity + (dt / 2) * rhs_2
    v_3, delta_p = make_incompressible(v_3_old, solve=pressure_solve, order=pressure_order)
    p_3 = p_2 + delta_p / dt
    # PDE at corrected half-point
    rhs_3 = pde(v_3, **pde_aux_kwargs) - field.spatial_gradient(p_3, type=StaggeredGrid, order=pressure_order)
    v_4_old = velocity + dt * rhs_2
    v_4, delta_p = make_incompressible(v_4_old, solve=pressure_solve, order=pressure_order)
    p_4 = p_3 + delta_p / dt
    # PDE at RK4 point
    rhs_4 = pde(v_4, **pde_aux_kwargs) - field.spatial_gradient(p_4, type=StaggeredGrid, order=pressure_order)
    v_p1_old = velocity + (dt / 6) * (rhs_1 + 2 * rhs_2 + 2 * rhs_3 + rhs_4)
    p_p1_old = (1 / 6) * (p_1 + 2 * p_2 + 2 * p_3 + p_4)
    v_p1, delta_p = make_incompressible(v_p1_old, solve=pressure_solve, order=pressure_order)
    p_p1 = p_p1_old + delta_p / dt
    return v_p1, p_p1</code></pre>
</details>
</dd>
<dt id="phi.physics.fluid.make_incompressible"><code class="name flex">
<span>def <span class="ident">make_incompressible</span></span>(<span>velocity:Â ~GridType, obstacles:Â Union[<a title="phi.physics.fluid.Obstacle" href="#phi.physics.fluid.Obstacle">Obstacle</a>,Â phi.geom._geom.Geometry,Â tuple,Â list]Â =Â (), solve:Â phiml.math._optimize.SolveÂ =Â auto with tolerance None (rel), None (abs), max_iterations=1000, active:Â phi.field._grid.CenteredGridÂ =Â None, order:Â intÂ =Â 2) â€‘>Â Tuple[~GridType,Â phi.field._grid.CenteredGrid]</span>
</code></dt>
<dd>
<div class="desc"><p>Projects the given velocity field by solving for the pressure and subtracting its spatial_gradient.</p>
<p>This method is similar to :func:<code>field.divergence_free()</code> but differs in how the boundary conditions are specified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>velocity</code></strong></dt>
<dd>Vector field sampled on a grid.</dd>
<dt><strong><code>obstacles</code></strong></dt>
<dd><code><a title="phi.physics.fluid.Obstacle" href="#phi.physics.fluid.Obstacle">Obstacle</a></code> or <code><a title="phi.geom.Geometry" href="../geom/index.html#phi.geom.Geometry">Geometry</a></code> or tuple/list thereof to specify boundary conditions inside the domain.</dd>
<dt><strong><code>solve</code></strong></dt>
<dd><code>Solve</code> object specifying method and tolerances for the implicit pressure solve.</dd>
<dt><strong><code>active</code></strong></dt>
<dd>(Optional) Mask for which cells the pressure should be solved.
If given, the velocity may take <code>NaN</code> values where it does not contribute to the pressure.
Also, the total divergence will never be subtracted if active is given, even if all values are 1.</dd>
<dt><strong><code>order</code></strong></dt>
<dd>spatial order for derivative computations.
For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.
While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.
supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>velocity</code></dt>
<dd>divergence-free velocity of type <code>type(velocity)</code></dd>
<dt><code>pressure</code></dt>
<dd>solved pressure field, <code>CenteredGrid</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_incompressible(velocity: GridType,
                        obstacles: Union[Obstacle, Geometry, tuple, list] = (),
                        solve: Solve = Solve(),
                        active: CenteredGrid = None,
                        order: int = 2) -&gt; Tuple[GridType, CenteredGrid]:
    &#34;&#34;&#34;
    Projects the given velocity field by solving for the pressure and subtracting its spatial_gradient.
    
    This method is similar to :func:`field.divergence_free()` but differs in how the boundary conditions are specified.

    Args:
        velocity: Vector field sampled on a grid.
        obstacles: `Obstacle` or `phi.geom.Geometry` or tuple/list thereof to specify boundary conditions inside the domain.
        solve: `Solve` object specifying method and tolerances for the implicit pressure solve.
        active: (Optional) Mask for which cells the pressure should be solved.
            If given, the velocity may take `NaN` values where it does not contribute to the pressure.
            Also, the total divergence will never be subtracted if active is given, even if all values are 1.
        order: spatial order for derivative computations.
            For Higher-order schemes, the laplace operation is not conducted with a stencil exactly corresponding to the one used in divergence calculations but a smaller one instead.
            While this disrupts the formal correctness of the method it only induces insignificant errors and yields considerable performance gains.
            supported: explicit 2/4th order - implicit 6th order (obstacles are only supported with explicit 2nd order)

    Returns:
        velocity: divergence-free velocity of type `type(velocity)`
        pressure: solved pressure field, `CenteredGrid`
    &#34;&#34;&#34;
    obstacles = _get_obstacles_for(obstacles, velocity)
    assert order == 2 or len(obstacles) == 0, f&#34;obstacles are not supported with higher order schemes&#34;
    input_velocity = velocity
    # --- Create masks ---
    accessible_extrapolation = _accessible_extrapolation(input_velocity.extrapolation)
    with NUMPY:
        accessible = CenteredGrid(~union([obs.geometry for obs in obstacles]), accessible_extrapolation, velocity.bounds, velocity.resolution)
        hard_bcs = field.stagger(accessible, math.minimum, input_velocity.extrapolation, type=type(velocity))
    all_active = active is None
    if active is None:
        active = accessible.with_extrapolation(extrapolation.NONE)
    else:
        active *= accessible  # no pressure inside obstacles
    # --- Linear solve ---
    velocity = apply_boundary_conditions(velocity, obstacles)
    div = divergence(velocity, order=order) * active
    if not all_active:  # NaN in velocity allowed
        div = field.where(field.is_finite(div), div, 0)
    if not input_velocity.extrapolation.is_flexible and all_active:
        solve = solve.with_preprocessing(_balance_divergence, active)
    if solve.x0 is None:
        pressure_extrapolation = _pressure_extrapolation(input_velocity.extrapolation)
        solve = copy_with(solve, x0=CenteredGrid(0, pressure_extrapolation, div.bounds, div.resolution))
    if batch(math.merge_shapes(*obstacles)).without(batch(solve.x0)):  # The initial pressure guess must contain all batch dimensions
        solve = copy_with(solve, x0=expand(solve.x0, batch(math.merge_shapes(*obstacles))))
    pressure = math.solve_linear(masked_laplace, div, solve, hard_bcs, active, order=order)
    # --- Subtract grad p ---
    grad_pressure = field.spatial_gradient(pressure, input_velocity.extrapolation, type=type(velocity), order=order) * hard_bcs
    velocity = (velocity - grad_pressure).with_extrapolation(input_velocity.extrapolation)
    return velocity, pressure</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phi.physics.fluid.Obstacle"><code class="flex name class">
<span>class <span class="ident">Obstacle</span></span>
<span>(</span><span>geometry, velocity=0, angular_velocity=0)</span>
</code></dt>
<dd>
<div class="desc"><p>An obstacle defines boundary conditions inside a geometry.
It can also have a linear and angular velocity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong></dt>
<dd>Physical shape and size of the obstacle.</dd>
<dt><strong><code>velocity</code></strong></dt>
<dd>Linear velocity vector of the obstacle.</dd>
<dt><strong><code>angular_velocity</code></strong></dt>
<dd>Rotation speed of the obstacle. Scalar value in 2D, vector in 3D.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Obstacle:
    &#34;&#34;&#34;
    An obstacle defines boundary conditions inside a geometry.
    It can also have a linear and angular velocity.
    &#34;&#34;&#34;

    def __init__(self, geometry, velocity=0, angular_velocity=0):
        &#34;&#34;&#34;
        Args:
            geometry: Physical shape and size of the obstacle.
            velocity: Linear velocity vector of the obstacle.
            angular_velocity: Rotation speed of the obstacle. Scalar value in 2D, vector in 3D.
        &#34;&#34;&#34;
        self.geometry = geometry
        self.velocity = wrap(velocity, channel(geometry)) if isinstance(velocity, (tuple, list)) else velocity
        self.angular_velocity = angular_velocity
        self.shape = shape(geometry) &amp; non_channel(self.velocity) &amp; non_channel(angular_velocity)

    @property
    def is_stationary(self):
        &#34;&#34;&#34; Test whether the obstacle is completely still. &#34;&#34;&#34;
        return not self.is_moving and not self.is_rotating

    @property
    def is_rotating(self):
        available = self.angular_velocity.available if isinstance(self.angular_velocity, math.Tensor) else True
        return not available or math.any(self.angular_velocity != 0).any

    @property
    def is_moving(self):
        available = self.velocity.available if isinstance(self.velocity, math.Tensor) else True
        return not available or math.any(self.velocity != 0).any

    def copied_with(self, **kwargs):
        warnings.warn(&#34;Obstacle.copied_with is deprecated. Use math.copy_with instead.&#34;, DeprecationWarning, stacklevel=2)
        return math.copy_with(self, **kwargs)

    def __variable_attrs__(self) -&gt; Tuple[str, ...]:
        return &#39;geometry&#39;, &#39;velocity&#39;, &#39;angular_velocity&#39;

    def __eq__(self, other):
        if not isinstance(other, Obstacle):
            return False
        return self.geometry == other.geometry and self.velocity == other.velocity and self.angular_velocity == other.angular_velocity</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="phi.physics.fluid.Obstacle.is_moving"><code class="name">var <span class="ident">is_moving</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_moving(self):
    available = self.velocity.available if isinstance(self.velocity, math.Tensor) else True
    return not available or math.any(self.velocity != 0).any</code></pre>
</details>
</dd>
<dt id="phi.physics.fluid.Obstacle.is_rotating"><code class="name">var <span class="ident">is_rotating</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_rotating(self):
    available = self.angular_velocity.available if isinstance(self.angular_velocity, math.Tensor) else True
    return not available or math.any(self.angular_velocity != 0).any</code></pre>
</details>
</dd>
<dt id="phi.physics.fluid.Obstacle.is_stationary"><code class="name">var <span class="ident">is_stationary</span></code></dt>
<dd>
<div class="desc"><p>Test whether the obstacle is completely still.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_stationary(self):
    &#34;&#34;&#34; Test whether the obstacle is completely still. &#34;&#34;&#34;
    return not self.is_moving and not self.is_rotating</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phi.physics.fluid.Obstacle.copied_with"><code class="name flex">
<span>def <span class="ident">copied_with</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copied_with(self, **kwargs):
    warnings.warn(&#34;Obstacle.copied_with is deprecated. Use math.copy_with instead.&#34;, DeprecationWarning, stacklevel=2)
    return math.copy_with(self, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phi.physics" href="index.html">phi.physics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phi.physics.fluid.apply_boundary_conditions" href="#phi.physics.fluid.apply_boundary_conditions">apply_boundary_conditions</a></code></li>
<li><code><a title="phi.physics.fluid.boundary_push" href="#phi.physics.fluid.boundary_push">boundary_push</a></code></li>
<li><code><a title="phi.physics.fluid.incompressible_rk4" href="#phi.physics.fluid.incompressible_rk4">incompressible_rk4</a></code></li>
<li><code><a title="phi.physics.fluid.make_incompressible" href="#phi.physics.fluid.make_incompressible">make_incompressible</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phi.physics.fluid.Obstacle" href="#phi.physics.fluid.Obstacle">Obstacle</a></code></h4>
<ul class="">
<li><code><a title="phi.physics.fluid.Obstacle.copied_with" href="#phi.physics.fluid.Obstacle.copied_with">copied_with</a></code></li>
<li><code><a title="phi.physics.fluid.Obstacle.is_moving" href="#phi.physics.fluid.Obstacle.is_moving">is_moving</a></code></li>
<li><code><a title="phi.physics.fluid.Obstacle.is_rotating" href="#phi.physics.fluid.Obstacle.is_rotating">is_rotating</a></code></li>
<li><code><a title="phi.physics.fluid.Obstacle.is_stationary" href="#phi.physics.fluid.Obstacle.is_stationary">is_stationary</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>